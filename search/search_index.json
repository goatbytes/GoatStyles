{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GoatStyles \u2014 Professional Code Style Guides","text":"<p> Welcome to our platform for professional code style guides, where we strive to uphold the highest standards of software engineering.</p> <p>In the realm of code style guides, we understand that opinions vary, and decisions often balance between necessity and subjectivity. However, amidst this diversity of perspectives, one principle remains paramount: consistency. By adhering to a consistent style, developers can enhance readability, maintainability, and collaboration within their codebases. The  Foundational Code Standards serve as a universal guideline, ensuring that language-specific style guides uphold these ideals of clarity and cohesiveness.</p>"},{"location":"#language-specific-style-guidelines","title":"Language-Specific Style Guidelines","text":"<p>C++</p> <p>C#</p> <p>Dart</p> <p>Go</p> <p>Java</p> <p>JavaScript</p> <p>Kotlin</p> <p>Objective-C</p> <p>Python</p> <p>Rust</p> <p>Swift</p> <p>TypeScript</p> <p>Each guideline outlined in our style guides is carefully curated to promote best practices and address common pitfalls specific to the respective programming languages. By following these guidelines, developers can write code that is not only consistent but also optimized for readability and maintainability.</p>"},{"location":"#badges","title":"Badges","text":"<p>Enhance your project's documentation by adding our style guide badges, signaling to fellow developers the coding standards and conventions your project adheres to. Each badge links directly to a comprehensive style guide for its respective programming language.</p> <p>Copy Markdown Snippets for Badges</p> <pre><code>[![Style Guide-C++](https://img.shields.io/badge/Style%20Guide-C++-00599C.svg?style=flat&amp;labelColor=black&amp;color=00599C&amp;logo=cplusplus)](https://styles.goatbytes.io/lang/cpp)\n</code></pre> <pre><code>[![Style Guide-C#](https://img.shields.io/badge/Style%20Guide-C%23-178600.svg?style=flat&amp;labelColor=black&amp;color=178600&amp;logo=csharp)](https://styles.goatbytes.io/lang/csharp)\n</code></pre> <pre><code>[![Style Guide-Dart](https://img.shields.io/badge/Style%20Guide-Dart-00B4AB.svg?style=flat&amp;labelColor=black&amp;color=00B4AB&amp;logo=dart)](https://styles.goatbytes.io/lang/dart)\n</code></pre> <pre><code>[![Style Guide-Go](https://img.shields.io/badge/Style%20Guide-Go-00ADD8.svg?style=flat&amp;labelColor=black&amp;color=00ADD8&amp;logo=go)](https://styles.goatbytes.io/lang/go)\n</code></pre> <pre><code>[![Style Guide-Java](https://img.shields.io/badge/Style%20Guide-Java-ED8B00.svg?style=flat&amp;labelColor=black&amp;color=ED8B00&amp;logo=java)](https://styles.goatbytes.io/lang/java)\n</code></pre> <pre><code>[![Style Guide-JavaScript](https://img.shields.io/badge/Style%20Guide-JavaScript-F0DB4F.svg?style=flat&amp;labelColor=black&amp;color=F0DB4F&amp;logo=javascript)](https://styles.goatbytes.io/lang/javascript)\n</code></pre> <pre><code>[![Style Guide-Kotlin](https://img.shields.io/badge/Style%20Guide-Kotlin-7F52FF.svg?style=flat&amp;labelColor=black&amp;color=7F52FF&amp;logo=kotlin)](https://styles.goatbytes.io/lang/kotlin)\n</code></pre> <pre><code>[![Style Guide-Objective-C](https://img.shields.io/badge/Style%20Guide-Objective--C-438EFF.svg?style=flat&amp;labelColor=black&amp;color=438EFF)](https://styles.goatbytes.io/lang/objective-c)\n</code></pre> <pre><code>[![Style Guide-Python](https://img.shields.io/badge/Style%20Guide-Python-3776AB.svg?style=flat&amp;labelColor=black&amp;color=3776AB&amp;logo=python)](https://styles.goatbytes.io/lang/python)\n</code></pre> <pre><code>[![Style Guide-Rust](https://img.shields.io/badge/Style%20Guide-Rust-DEA584.svg?style=flat&amp;labelColor=black&amp;color=DEA584&amp;logo=rust)](https://styles.goatbytes.io/lang/rust)\n</code></pre> <pre><code>[![Style Guide-Shell](https://img.shields.io/badge/Style%20Guide-Shell-4EAA25.svg?style=flat&amp;labelColor=black&amp;color=4EAA25&amp;logo=gnu-bash)](https://styles.goatbytes.io/lang/shell)\n</code></pre> <pre><code>[![Style Guide-Swift](https://img.shields.io/badge/Style%20Guide-Swift-FA7343.svg?style=flat&amp;labelColor=black&amp;color=FA7343&amp;logo=swift)](https://styles.goatbytes.io/lang/swift)\n</code></pre> <pre><code>[![Style Guide-TypeScript](https://img.shields.io/badge/Style%20Guide-TypeScript-3178C6.svg?style=flat&amp;labelColor=black&amp;color=3178C6&amp;logo=typescript)](https://styles.goatbytes.io/lang/typescript)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>GoatStyles is licensed under Attribution-ShareAlike 4.0 International</p>"},{"location":"about/","title":"About GoatBytes.IO","text":"<p>At GoatBytes.IO, our mission is to develop secure software solutions that empower businesses to transform the world. We are a team of ethical software engineers specializing in custom software development, focusing on delivering top-quality services that prioritize security and ethical practices.</p>"},{"location":"about/#our-mission","title":"Our Mission","text":"<p>In a world where technology increasingly touches every aspect of our lives, we believe in the power of secure and reliable software to make a positive impact. Our mission is centered on developing solutions that not only meet the evolving needs of businesses but also contribute to a better and safer digital future for everyone.</p>"},{"location":"about/#what-we-do","title":"What We Do","text":"<ul> <li>Custom Software Development: Tailoring solutions to meet the unique needs of each client, ensuring performance, security, and scalability.</li> <li>Security Solutions: Building software with security at its core, protecting businesses and their customers from evolving digital threats.</li> <li>Empowerment through AI: We harness the power of artificial intelligence to provide businesses with cutting-edge solutions, enabling smarter decision-making and streamlined operations.</li> <li>Software Modernization: Understanding the importance of keeping pace with technology, we offer software modernization services to revitalize legacy systems, improve performance, and ensure scalability. This approach not only extends the life of existing applications but also prepares your business for future growth and innovation.</li> </ul>"},{"location":"about/#join-us","title":"Join Us","text":"<p>We are on a mission to make the world a better place through secure software development. If you share our passion for technology, innovation, and ethics, join us in shaping the future of software development.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For more information about our services, or to discuss how we can help your business, please contact us.</p> <p>Thank you for considering GoatBytes.IO as your partner in software development.</p>"},{"location":"contributing/","title":"Contributing to GoatStyles","text":"<p>We're thrilled that you're interested in contributing to GoatStyles! This project is a repository for professional code style guides used by GoatBytes.IO and the wider software development community. Our aim is to uphold the highest standards of software engineering practices, making the development process more efficient and secure.</p>"},{"location":"contributing/#using-the-style-guides","title":"Using the Style Guides","text":"<p>GoatStyles is actively used by GoatBytes.IO internally to ensure consistency, quality, and security across our projects. The style guides within this repository reflect our current best practices and are subject to updates as our standards evolve.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>We welcome contributions from the community! Whether you're fixing a typo, proposing a new section, or suggesting changes to an existing guide, your input is valuable. Here's how you can contribute:</p>"},{"location":"contributing/#fork-the-repository","title":"Fork the Repository","text":"<p>Due to the diversity in coding standards across different organizations, we recommend creating a  fork of the GoatStyles repository for any significant modifications or additions. This approach  allows you to customize the style guides to better fit your organizational needs while contributing  valuable insights back to the main project.</p>"},{"location":"contributing/#submitting-pull-requests-prs","title":"Submitting Pull Requests (PRs)","text":"<ol> <li> <p>Individual Contributor License Agreement (CLA): Before we can accept your contributions, you     must complete our Individual Contributor License Agreement (CLA). This legal document     ensures that your contributions can be included in the project without licensing issues.</p> </li> <li> <p>Make Your Changes: Once the CLA is signed, make your proposed changes in your forked     repository. Please ensure that your changes adhere to the existing format and standards of the     style guides.</p> </li> <li> <p>Submit a Pull Request: After you've made your changes, submit a PR to the main GoatStyles     repository. Include a clear description of your changes and any additional context that might     help in the review process.</p> </li> </ol>"},{"location":"contributing/#review-process","title":"Review Process","text":"<p>All PRs will undergo a review process by the GoatStyles team. While we value every contribution,  PRs may be closed if they do not align with our internal standards or current needs. However,  suggestions for improvement are always welcome, and we encourage contributors to engage in  discussions about their proposals.</p>"},{"location":"contributing/#encouragement-for-contributions","title":"Encouragement for Contributions","text":"<p>Even if your PR does not get merged, your contributions play a crucial role in the continuous  improvement of GoatStyles. We encourage you to maintain your fork and share your customizations  with the community. Your insights and enhancements can greatly benefit others and lead to valuable  discussions and ideas for future updates.</p>"},{"location":"contributing/#questions-or-suggestions","title":"Questions or Suggestions?","text":"<p>If you have any questions or suggestions about contributing to GoatStyles, please feel free to open  an issue in the repository. We're always looking for ways to improve the project and appreciate  your feedback.</p> <p>Thank you for contributing to GoatStyles and helping us enhance the standards of software  engineering practices!</p>"},{"location":"foundation/","title":"Foundational Code Standards","text":"<p>These Foundational Code Standards establish a core set of best practices for software development. They serve as the foundation for our language-specific style guides, promoting code clarity, consistency, maintainability, and security.</p>"},{"location":"foundation/#general-principles","title":"General Principles","text":""},{"location":"foundation/#compass-navigate-your-way-to-exceptional-code","title":"COMPASS: Navigate Your Way to Exceptional Code","text":"<p>The journey towards exceptional software requires a well-defined compass \u2013 a set of core principles to guide development practices. The COMPASS acronym, encompassing Consistency, Optimized, Maintainable, Performance, Adaptable, Scalable, and Secure, offers a valuable framework for building high-quality, efficient, and demonstrably secure codebases. These principles seamlessly integrate with established software development practices, fostering a strong foundation for success.</p> Adopt a Unified Coding Standard: Consistency minimizes complexity and fosters seamless   collaboration. By adhering to a shared set of coding standards, developers can ensure their   codebase remains accessible and maintainable for everyone. Readability and clarity are paramount,   allowing developers of all experience levels to navigate and understand the code with ease. This   focus on consistency promotes long-term maintainability of the project. Balance Efficiency with Clarity: While performance is a priority, optimizations should be   implemented judiciously, with a keen eye on maintaining readability and future maintainability.   The key lies in achieving performance gains without obscuring the code's original intent. Clear,   well-structured code that performs efficiently \u2013 that's the objective. Write for the Future: Embracing practices that look ahead to future developments creates code   that is inherently adaptable and easy to update. This approach ensures resilience and smooth   evolution alongside new technologies and requirements, prioritizing maintainability as a core   principle. Responsibly Utilize Resources: Performant code is a cornerstone of exceptional software. This   means writing code that utilizes system resources meticulously, delivering a responsive and   seamless user experience. Efficiency is key, integrating considerations for algorithm efficiency   and resource management throughout the development process. Importantly, performance enhancements   should never come at the expense of code readability or future maintainability. Embrace Change: The software development landscape is inherently dynamic. Designing code to be   flexible and open to change is paramount. This adaptability allows for seamless integration of new   technologies and methodologies, keeping projects at the forefront of innovation. Plan for Growth: Scalability should be central to development strategies. By adopting coding   practices and architectural decisions that allow the system to handle increasing loads and   complexity gracefully, applications can be built to grow and adapt to expanding user bases and   data volumes. Prioritize Security: Security should be woven into the very fabric of the development process.   By incorporating robust security practices from the outset, developers can prioritize user data   protection and system integrity. Mitigating potential vulnerabilities throughout the development   lifecycle is paramount. <p>Promoting these principles aims to inspire a commitment to excellence, security, and efficiency across the global software development community, encouraging a collaborative approach to creating software that is both innovative and enduring.</p>"},{"location":"foundation/#consistency","title":"Consistency","text":""},{"location":"foundation/#optimized","title":"Optimized","text":""},{"location":"foundation/#maintainable","title":"Maintainable","text":""},{"location":"foundation/#performance","title":"Performance","text":""},{"location":"foundation/#adaptable","title":"Adaptable","text":""},{"location":"foundation/#scalable","title":"Scalable","text":""},{"location":"foundation/#secure","title":"Secure","text":""},{"location":"foundation/#formatting","title":"Formatting","text":"<p>Note</p> <p>While adhering to these formatting guidelines is recommended for new projects to ensure readability, maintainability, and consistency, they are not rigid requirements. The overarching principle is to maintain consistency within a project or team. In cases where an existing codebase already follows a well-structured and defined formatting style, it may not be beneficial to reformat the code solely to align with these guidelines. For GoatBytes.IO projects, this represents the preferred style, but flexibility is key, especially when collaborating on or contributing to projects with established conventions.</p>"},{"location":"foundation/#indentation","title":"Indentation","text":"<ul> <li>Use 2 spaces for indentation to ensure code is readable on various editors and platforms.<ul> <li>Exceptions:<ul> <li>C++, Python, Rust: Use 4 spaces for indentation.</li> <li>Go: Use tabs for indentation.</li> </ul> </li> </ul> </li> <li>Use 4 spaces for continuation lines to distinguish them from regular indents.</li> </ul>"},{"location":"foundation/#line-length","title":"Line Length","text":"<ul> <li>Enforce a maximum line length of 100 characters to improve readability and manageability.   Allow flexibility in cases where breaking lines would reduce readability or disrupt the logical   flow of the code.</li> </ul>"},{"location":"foundation/#whitespace","title":"Whitespace","text":"<ul> <li>Include a space before parentheses and the left brace <code>{</code> for control structures   (<code>if</code>, <code>for</code>, <code>while</code>, etc.).</li> <li>Include Space around all operators (<code>-&gt;</code>, <code>=</code>, <code>+</code>, <code>*</code>, <code>/</code>, <code>&gt;&gt;</code>, etc.), except before unary and   range operators.</li> <li>Include a space before <code>else</code>, <code>catch</code>, and <code>finally</code> keywords.</li> <li>Include space around ternary and Elvis operators.</li> <li>Add a space after commas in type arguments and other comma-separated lists.</li> <li>Ensure a space before and after a colon in contexts like dictionary entries or type annotations.</li> </ul>"},{"location":"foundation/#brace-style","title":"Brace Style","text":"<ul> <li>Adopt the K&amp;R brace style:   <pre><code>if (x &lt; 0) {\n  printf(\"Negative\");\n}\n</code></pre></li> <li>Braces are not required for single-line blocks but may provide clarity.</li> </ul>"},{"location":"foundation/#blank-lines-and-spacing","title":"Blank Lines and Spacing","text":"<p>Use blank lines strategically to separate logical blocks of code for better readability.</p> <ul> <li>Use <code>0</code> blank lines in certain areas like before <code>}</code>, or around field declarations.</li> <li>Use <code>1</code> maximum blank line in areas like between method definitions or after class definitions.</li> <li>Use <code>2</code> maximum blank lines to separate sections more distinctly (e.g. package declarations).</li> </ul>"},{"location":"foundation/#alignment","title":"Alignment","text":"<ul> <li>Align descriptions of parameters, exceptions, and properties in documentation comments.</li> <li>Align parameter lists and constructor arguments for readability.</li> </ul>"},{"location":"foundation/#examples","title":"Examples","text":"C++C#DartGoJavaJavaScriptKotlinObjective-CPythonRustShellSwiftTypeScript <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 4 spaces for indentation (C++ exception).\n * - 8 spaces for continuation lines (C++ exception).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode/*(1)!*/ {\npublic:\n    /**\n     * This method calculates the factorial of a given positive integer.\n     *\n     * @param n The non-negative integer for which to calculate the factorial.\n     * @return  The factorial of n, or throws an std::invalid_argument exception if n is negative.\n     * @throws std::invalid_argument If the provided number (n) is negative.\n     */\n    static long calculateFactorial(int n) { // (2)!\n        if (n &lt; 0) { // (3)!\n            throw std::invalid_argument(\"Factorial is not defined for negative numbers.\");\n        }\n\n        long result = 1;\n        for (int i = 2; i &lt;= n; ++i) { // (4)!\n            result *= i;\n        }\n        return result;\n    }\n};\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - Indentation: 2 spaces (C# standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style (opening brace on the same line as the statement).\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\npublic class WellFormattedCode { // (1)!\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an ArgumentOutOfRangeException if n is negative.\n   * @throws ArgumentOutOfRangeException If the provided number (n) is negative.\n   */\n  public static long CalculateFactorial(int n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw new ArgumentOutOfRangeException(nameof(n), \"Factorial is not defined for negative numbers.\");\n    }\n\n    long result = 1;\n    for (int i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation (Dart standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return The factorial of n, or throws an ArgumentError if n is negative.\n   * @throws ArgumentError If the provided number (n) is negative.\n   */\n  int calculateFactorial(int n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw ArgumentError('Factorial is not defined for negative numbers.');\n    }\n\n    int result = 1;\n    for (int i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - Tabs for indentation (Go standard).\n * - 8 spaces for continuation lines (Go exception).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\ntype WellFormattedCode struct{} // (1)!\n\n// calculateFactorial calculates the factorial of a given positive integer.\n//\n// @param n The non-negative integer for which to calculate the factorial.\n// @return The factorial of n, or throws a panic with an error message if n is negative.\nfunc (w *WellFormattedCode) calculateFactorial(n int) int64 { // (2)!\n    if n &lt; 0 { // (3)!\n        panic(\"Factorial is not defined for negative numbers.\")\n    }\n\n    var result int64 = 1\n    for i := 2; i &lt;= n; i++ { // (4)!\n        result *= int64(i)\n    }\n    return result\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation.\n * - 4 spaces for continuation lines.\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\npublic class WellFormattedCode { // (1)!\n\n  /**\n   * This method calculates the factorial of a given positive integer. // Doc comment for method\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an IllegalArgumentException if n is negative.\n   * @throws IllegalArgumentException If the provided number (n) is negative.\n   */\n  public static long calculateFactorial(int n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw new IllegalArgumentException(\"Factorial is not defined for negative numbers.\");\n    }\n\n    long result = 1;\n    for (int i = 2; i &lt;= n; i++) {  // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param {number} n The non-negative integer for which to calculate the factorial.\n   * @return {number} The factorial of n, or throws a TypeError if n is negative.\n   * @throws {TypeError} If the provided number (n) is negative.\n   */\n  calculateFactorial(n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw new TypeError('Factorial is not defined for negative numbers.');\n    }\n\n    let result = 1;\n    for (let i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation.\n * - 4 spaces for continuation lines.\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n\n  /**\n   * This method calculates the factorial of a given positive integer. // Doc comment for method\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an IllegalArgumentException if n is negative.\n   * @throws IllegalArgumentException If the provided number (n) is negative.\n   */\n  fun calculateFactorial(n: Int): Long { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw IllegalArgumentException(\"Factorial is not defined for negative numbers.\")\n    }\n\n    var result = 1L\n    for (i in 2..n) {  // (4)!\n      result *= i\n    }\n    return result\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and method arguments.\n * - Doc comments with aligned descriptions.\n */\n@interface WellFormattedCode : NSObject\n\n/**\n * This method calculates the factorial of a given positive integer.\n *\n * @param n The non-negative integer for which to calculate the factorial.\n * @return The factorial of n, or throws an NSException if n is negative.\n * @throws NSException If the provided number (n) is negative.\n */\n- (long)calculateFactorial:(int)n;\n\n@end\n\n@implementation WellFormattedCode // (1)!\n\n- (long)calculateFactorial:(int)n {  // (2)!\n  if (n &lt; 0) {  // (3)!\n    @throw [NSException exceptionWithName:@\"FactorialError\"\n                                   reason:@\"Factorial is not defined for negative numbers.\"\n                                 userInfo:nil];\n  }\n\n  long result = 1;\n  for (int i = 2; i &lt;= n; i++) {  // (4)!\n    result *= i;\n  }\n  return result;\n}\n\n@end\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>\"\"\"\nThis class demonstrates proper code formatting following the specified style guide.\n\n**Formatting Rules:**\n * 4 spaces for indentation (Python exception).\n * Max line length of 100 characters.\n * Spaces around operators, control structures, and keywords.\n * K&amp;R brace style.\n * Consistent spacing for parameter lists and function arguments.\n * Docstrings with aligned descriptions.\n\"\"\"\nclass WellFormattedCode:  # (1)!\n    \"\"\"\n    This method calculates the factorial of a given positive integer.\n\n    Args:\n            n: The non-negative integer for which to calculate the factorial.\n\n    Returns:\n            The factorial of n, or throws a ValueError if n is negative.\n\n    Raises:\n            ValueError: If the provided number (n) is negative.\n    \"\"\"\n    def calculate_factorial(self, n: int) -&gt; int:  # (2)!\n        if n &lt; 0:  # (3)!\n            raise ValueError(\"Factorial is not defined for negative numbers.\")\n\n        result = 1\n        for i in range(2, n + 1):  # (4)!\n            result *= i\n        return result\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>//! This module demonstrates proper code formatting following the specified style guide.\n\nuse std::error::Error;\n\n/// This function calculates the factorial of a given positive integer.\n///\n/// # Arguments\n/// * `n` - The non-negative integer for which to calculate the factorial.\n///\n/// # Returns\n/// * The factorial of n, or a `Result` with an error if n is negative.\n///\n/// # Errors\n/// This function returns an error if the provided number (n) is negative.\nfn calculate_factorial(n: u32) -&gt; Result&lt;u64, Box&lt;dyn Error&gt;&gt; { // (1)!\n    if n &lt; 0 { // (2)!\n        Err(Box::new(std::fmt::Error::new(\"Factorial is not defined for negative numbers.\"))) \n    } else {\n        let mut result = 1u64;\n        for i in 2..=n { // (3)!\n            result *= i;\n        }\n        Ok(result)\n    }\n}\n</code></pre> <ol> <li>snake_case for function and method names, local variables, struct fields, macro names,        and properties</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>#!/bin/bash\n\n# This script demonstrates proper code formatting following the specified style guide.\n\n# Formatting Rules:\n# - Uses shebang (#!) for interpreter declaration.\n# - 2 spaces for indentation.\n# - Max line length of 100 characters (recommended).\n# - Meaningful variable names.\n# - Consistent spacing around operators and control structures.\n# - Use of comments to explain complex logic.\n# - Error handling (optional for this example).\n\n# Function to calculate the factorial of a non-negative integer\ncalculate_factorial() {\n  # Check if a number is provided as an argument\n  if [[ -z \"$1\" ]]; then\n    echo \"Error: Please provide a non-negative integer as an argument.\"\n    exit 1\n  fi\n\n  # Check if the argument is negative\n  if [[ \"$1\" -lt 0 ]]; then\n    echo \"Error: Factorial is not defined for negative numbers.\"\n    exit 1\n  fi\n\n  # Local variable for result\n  local result=1\n\n  # Calculate factorial using a loop\n  for (( i=2; i&lt;=$1; i++ )); do\n    result=$(( result * i ))\n  done\n\n  # Print the factorial result\n  echo \"The factorial of $1 is: $result\"\n}\n\n# Call the function with a non-negative integer argument\ncalculate_factorial $2\n</code></pre> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation (Swift standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and method arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an IllegalArgumentException if n is negative.\n   * @throws IllegalArgumentException If the provided number (n) is negative.\n   */\n  func calculateFactorial(n: Int) -&gt; Long { // (2)!\n    if n &lt; 0 { // (3)!\n      throw IllegalArgumentException(\"Factorial is not defined for negative numbers.\")\n    }\n\n    var result = 1\n    for i in 2...n { // (4)!\n      result *= i\n    }\n    return result\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation (TypeScript standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\n\nclass WellFormattedCode { // (1)!\n\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an error if n is negative.\n   * @throws {Error} If the provided number (n) is negative.\n   */\n  public calculateFactorial/* (2)! */(n: number): number {\n    if (n &lt; 0) { // (3)!\n      throw new Error('Factorial is not defined for negative numbers.');\n    }\n\n    let result: number = 1;\n    for (let i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol>"},{"location":"foundation/#naming-conventions","title":"Naming Conventions","text":"<p>Adopting consistent naming conventions is fundamental to enhancing code readability and maintainability. By establishing clear patterns for naming various elements, developers can quickly understand the structure and purpose of the code.</p>"},{"location":"foundation/#general-approach","title":"General Approach","text":"<p>Consistent naming conventions serve as a quick guide to understanding code. They help in making the codebase easier to read, understand, and maintain. Remember, following language-specific style guides is crucial for maintaining consistent and readable code across the codebase.</p>"},{"location":"foundation/#case-types","title":"Case Types","text":"<ul> <li>PascalCase:<ul> <li>Used for classes, interfaces, and enum types, highlighting their use as definitions or   templates.</li> </ul> </li> <li>camelCase:<ul> <li>Employed for function names across most programming languages, with notable exceptions for   languages with their own idiomatic practices, such as Go and Python.</li> <li>Used for variable names, except in languages or scenarios where <code>snake_case</code> is the norm.</li> </ul> </li> <li>UPPER_SNAKE_CASE<ul> <li>Reserved for constants and Enum constants, signaling their immutable and static nature.</li> </ul> </li> <li>snake_case:<ul> <li>Preferred for variable and function names in Python, Ruby, and for keys in JSON objects,   aligning with these languages' and data formats' conventions.</li> </ul> </li> </ul>"},{"location":"foundation/#variables","title":"Variables","text":"<ul> <li>Boolean Variables: Prefix boolean variables and functions with <code>is</code> or <code>has</code> to indicate a   true or false value, enhancing their interpretability.</li> <li>Temporary Variables: Temp variables should be both short and descriptive, providing clarity on   their purpose or use case.</li> <li>Loop Indices: Use single-letter abbreviations (e.g., <code>i</code>, <code>j</code>, <code>k</code>) for loop indices,   maintaining simplicity and tradition in loop constructs.</li> </ul>"},{"location":"foundation/#files-and-directories","title":"Files and Directories","text":"<ul> <li>Package Names: Should be all lowercase, with multiple words concatenated together without   underscores, ensuring consistency and avoiding conflict with language keywords or conventions.</li> <li>Folder Names: Use descriptive names for folders within your project to group related   functionalities, features or modules.</li> </ul>"},{"location":"foundation/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Effective documentation and thoughtful comments are crucial for maintaining high code readability and understandability. They help developers quickly grasp the purpose and logic behind code, facilitating easier maintenance and future development.</p>"},{"location":"foundation/#writing-effective-code-comments","title":"Writing Effective Code Comments","text":"<ul> <li>Clarity is Key: Comments should illuminate the \"why\" behind the code's logic, not just   reiterate the \"what.\" Avoid redundant comments that merely echo the code itself.</li> <li>Live Documentation: Ensure comments remain relevant by updating them alongside the code they   describe. Outdated comments can be more misleading than no comments at all.</li> </ul>"},{"location":"foundation/#documenting-your-code","title":"Documenting Your Code","text":"<ul> <li>Comprehensive Documentation: All public classes, methods, and member variables must be clearly   documented. This documentation should succinctly explain the component's purpose, usage,   behaviors, parameters, return values, and exceptions thrown.</li> <li>Actionable Details: Incorporate code examples to demonstrate usage and expected outcomes,   providing developers with actionable insights into how components function within the system.</li> </ul>"},{"location":"foundation/#inline-comments-use-strategically","title":"Inline Comments: Use Strategically","text":"<ul> <li>For Complexity: Utilize inline comments to clarify complex code sections where the intent or   logic is not immediately obvious. This practice aids in demystifying intricate algorithms or   workflows.</li> <li>Placement Matters: Position inline comments directly above the relevant code segment to ensure   they are easily associated with the correct lines of code. Avoid end-of-line comments for complex   explanations to maintain readability.</li> </ul>"},{"location":"foundation/#todos-and-fixmes-track-with-a-system","title":"TODOs and FIXMEs: Track with a System","text":"<ul> <li>Tickets for the Win: While <code>TODO:</code> and <code>FIXME:</code> comments can highlight areas needing   refinement or further development, leveraging a dedicated issue tracking system is preferable.   This method ensures better task organization, prioritization, and resolution.</li> <li>Link to Trackers: When employing <code>TODO:</code> or <code>FIXME:</code> comments, always reference the   corresponding ticket number from your project's issue tracker. This connection ensures that   comments are actionable, facilitating direct access to detailed task descriptions and discussions.</li> </ul> Good<pre><code>// TODO: [TICKET-1001] Implement the laser beam functionality for the cat's collar.\n// FIXME: [TICKET-2001] The time machine's flux capacitor is not calculating leap years correctly.\n</code></pre> Bad<pre><code>// TODO: Make it better.\n// FIXME: It doesn't work.\n</code></pre>"},{"location":"foundation/#managing-deprecation-and-obsolete-code","title":"Managing Deprecation and Obsolete Code","text":"<ul> <li>Mark for Deprecation: Clearly label deprecated code segments with comments or annotations that   outline the reason for their deprecation and suggest any available alternatives.</li> <li>Clean Codebase: Aim to remove deprecated code in subsequent releases to avoid clutter and   confusion, promoting a cleaner, more maintainable codebase.</li> </ul>"},{"location":"foundation/#programming-practices","title":"Programming Practices","text":"<p>Adhering to sound programming practices not only ensures the creation of robust, maintainable, and secure software but also facilitates efficient team collaboration. Below, we detail key practices that underpin our development ethos.</p>"},{"location":"foundation/#code-simplicity-and-clarity","title":"Code Simplicity and Clarity","text":"<ul> <li>Focus on Readability: Prioritize writing code that is easily understandable, employing clear   variable names and well-defined functions.</li> <li>KISS Principle: Embrace simplicity in your solutions. If a simpler approach yields the same   result, prefer it over a more complex alternative.</li> <li>Small Functions: Decompose larger functions into smaller, focused units that are easier to   manage and understand.</li> </ul>"},{"location":"foundation/#error-handling","title":"Error Handling","text":"<ul> <li>Graceful Error Isolation: Utilize try-catch blocks where applicable to manage exceptions   effectively and maintain program stability.</li> <li>Informative Error Messages: Ensure error messages provide clear guidance on the issue and   possible resolutions.</li> <li>Anticipate and Manage Errors: Design your code to gracefully handle potential errors, keeping   the application robust and stable.</li> </ul>"},{"location":"foundation/#code-reusability-and-modularity","title":"Code Reusability and Modularity","text":"<ul> <li>Emphasize Reusability: Strive for a codebase where functionality is encapsulated in reusable   components, minimizing duplication and fostering consistency.</li> <li>Utilize Functions and Classes: Develop well-defined functions and classes that encapsulate   specific functionalities, making them reusable across projects.</li> <li>Create Modular Libraries: Build and maintain libraries or modules that can be easily   integrated into various projects, enhancing reusability.</li> </ul>"},{"location":"foundation/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Consider Performance Throughout: While not the initial focus, keep performance optimization in   mind throughout the development process, especially in critical code paths.</li> <li>Profiling Before Optimization: Use profiling tools to identify and understand performance   bottlenecks before embarking on optimization.</li> <li>Efficiency and Laziness: Choose efficient algorithms, avoid unnecessary computations, and   implement lazy loading where applicable.</li> </ul>"},{"location":"foundation/#security-practices","title":"Security Practices","text":"<ul> <li>Input Validation: Vigilantly validate user input to guard against injection attacks.</li> <li>Adhere to Secure Coding Guidelines: Follow established secure coding practices to mitigate   common vulnerabilities.</li> <li>Stay Updated: Regularly update dependencies to incorporate security fixes.</li> <li>Early Threat Consideration: Employ threat modeling early to identify and address security   risks effectively.</li> </ul>"},{"location":"foundation/#testing-and-quality-assurance","title":"Testing and Quality Assurance","text":"<ul> <li>Flexible Testing Approach: Adapt your testing strategy to fit the project and team, whether it   be TDD, BDD, or a mix of automated and manual testing.</li> <li>Quality Through CI/CD: Implement CI/CD pipelines to automate testing and deployment, ensuring   consistent quality and rapid feedback loops.</li> <li>Code Reviews for Quality: Regularly conduct code reviews focusing on code quality,   correctness, and security.</li> </ul>"},{"location":"foundation/#dependency-management","title":"Dependency Management","text":"<ul> <li>Effective Dependency Tools: Utilize dependency management tools appropriate to your technology   stack to maintain a consistent setup across environments.</li> <li>Security and Updates: Regularly review and update dependencies to mitigate vulnerabilities,   using tools to automate vulnerability scanning.</li> </ul>"},{"location":"foundation/#code-reviews-and-collaboration","title":"Code Reviews and Collaboration","text":"<ul> <li>Constructive Review Process: Ensure code reviews are thorough and constructive, providing   valuable feedback for improvement.</li> <li>Promote Open Communication: Encourage discussions and collaborative problem-solving during the   review process.</li> <li>Version Control Integration: Leverage version control systems to manage contributions and   facilitate code integration.</li> </ul>"},{"location":"foundation/#handling-technical-debt","title":"Handling Technical Debt","text":"<ul> <li>Proactive Identification: Use tools and code reviews to identify areas of technical debt,   prioritizing their resolution based on impact.</li> <li>Iterative Refactoring: Address technical debt in manageable portions, integrating small   refactorings into your regular development cycle.</li> <li>Balance and Continuous Improvement: Allocate time for addressing technical debt while   balancing new feature development, adopting a continuous improvement mindset.</li> </ul>"},{"location":"lang/cpp/","title":"C++ Style Guide","text":"<p>This guide specifically addresses C++ development, focusing on idiomatic practices, patterns, and C++-specific considerations.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for C++.</p>"},{"location":"lang/cpp/#formatting","title":"Formatting","text":"<p>The formatting rules for C++ adhere to our foundational formatting standards with the following exceptions:</p> <ul> <li>Indentation: Use 4 spaces for indentation.</li> <li>Continuation indent: Use 8 spaces for line continuations.</li> </ul> <p>Otherwise, follow the conventions outlined in the foundational standards, summarized below:</p> <ul> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords for   clarity.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/cpp/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Kotlin adhere to our foundational naming conventions with no exceptions.</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul> <p>Example</p> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 4 spaces for indentation (C++ exception).\n * - 8 spaces for continuation lines (C++ exception).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode/*(1)!*/ {\npublic:\n    /**\n     * This method calculates the factorial of a given positive integer.\n     *\n     * @param n The non-negative integer for which to calculate the factorial.\n     * @return  The factorial of n, or throws an std::invalid_argument exception if n is negative.\n     * @throws std::invalid_argument If the provided number (n) is negative.\n     */\n    static long calculateFactorial/*(2)!*/(int n) {\n        if (n &lt; 0) {// (3)!\n            throw std::invalid_argument(\"Factorial is not defined for negative numbers.\");\n        }\n\n        long result = 1;\n        for (int i = 2; i &lt;=/*(4)!*/ n; ++i) {\n            result *= i;\n        }\n        return result;\n    }\n};\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol>"},{"location":"lang/cpp/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Refer to the Foundational Documentation and Comments Standards for general commenting and  documentation guidelines.</p>"},{"location":"lang/cpp/#documentation-example","title":"Documentation Example","text":"<pre><code>#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n/**\n * Represents a goat with a name and age, offering functionality to determine its happiness.\n * \n * This class encapsulates essential attributes for a goat and provides a method to assess\n * the goat's happiness based on the number of meals it has received within a day.\n *\n * **Usage Example:**\n * `\n * Goat billy(\"Billy\", 5);\n * std::cout &lt;&lt; (billy.isHappy(3) ? \"True\" : \"False\") &lt;&lt; std::endl;\n * `\n * \n * @author Author's Name\n * @param name The name of the goat.\n * @param age The age of the goat in years. Must be non-negative.\n * @throws std::invalid_argument if the age is negative.\n */\nclass Goat {\npublic:\n    Goat(const std::string&amp; name, int age) : name_(name), age_(age) {\n        if (age &lt; 0) {\n            throw std::invalid_argument(\"Age cannot be negative\");\n        }\n    }\n\n    /**\n     * Determines if the goat is happy based on the number of meals it has received today.\n     * \n     * A goat is considered happy if it has been fed at least twice a day.\n     * \n     * @param meals The number of meals the goat has received today.\n     * @return true if the goat is happy (fed at least twice today), false otherwise.\n     * @throws std::invalid_argument if the number of meals is negative.\n     */\n    bool isHappy(int meals) const {\n        if (meals &lt; 0) {\n            throw std::invalid_argument(\"Meals cannot be negative\");\n        }\n        return meals &gt;= 2;\n    }\n\nprivate:\n    std::string name_;\n    int age_;\n};\n</code></pre>"},{"location":"lang/cpp/#idioms-and-best-practices","title":"Idioms and Best Practices","text":"<p>C++ offers a wealth of idiomatic practices and patterns that can enhance your code's efficiency, readability, and safety. This section focuses on leveraging C++'s unique features effectively.</p>"},{"location":"lang/cpp/#smart-pointers","title":"Smart Pointers","text":"<p>Use smart pointers (std::unique_ptr, std::shared_ptr, std::weak_ptr) for dynamic memory management to avoid leaks.</p>"},{"location":"lang/cpp/#raii","title":"RAII","text":"<p>Leverage Resource Acquisition Is Initialization (RAII) for managing resources like file handles and mutexes.</p>"},{"location":"lang/cpp/#move-semantics","title":"Move Semantics","text":"<p>Utilize move semantics to avoid unnecessary copying of objects, especially for return values and function arguments.</p>"},{"location":"lang/cpp/#constexpr","title":"constexpr","text":"<p>Prefer constexpr for compile-time initialization of constants to improve performance.</p>"},{"location":"lang/cpp/#rule-of-five","title":"Rule of Five","text":"<p>Follow the Rule of Five for classes that manage resources directly, ensuring proper copy and move semantics.</p>"},{"location":"lang/cpp/#templates","title":"Templates","text":"<p>Use templates for generic programming, allowing for code reuse across different data types.</p>"},{"location":"lang/cpp/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/cpp/#recommended-static-analysis-tools-for-c","title":"Recommended Static Analysis Tools for C++","text":"<p>For ensuring code quality and adherence to this style guide, we recommend integrating the following static analysis tools into your C++ development workflow:</p> <ul> <li>Cppcheck: A static analysis tool for C/C++ code that   detects various types of errors, including memory leaks, misuses of the standard library, and   more.</li> <li>Clang-Tidy: Part of the LLVM project, this linter   tool provides a framework for writing checks that detect errors, bugs, and stylistic issues in C++   code.</li> <li>Coverity: Offers static code analysis to identify software   vulnerabilities and compliance issues.</li> <li>CodeSonar: A comprehensive tool for static   analysis, detecting bugs, security vulnerabilities, and compliance violations in C and C++   codebases.</li> </ul>"},{"location":"lang/cpp/#additional-resources","title":"Additional Resources","text":"<p>To further enhance your C++ development skills and knowledge, consider exploring the following resources:</p> <ul> <li>C++ Core Guidelines: An   extensive set of guidelines maintained by the C++ community and the Standard C++ Foundation to   help C++ programmers achieve higher code quality.</li> <li>Effective Modern C++: A book by Scott Meyers that covers the effective   use of the C++11 and C++14 standards.</li> <li>The C++ Programming Language: Written by Bjarne   Stroustrup, the creator of C++, this book provides comprehensive coverage of the C++ language,   including its standard library and key design techniques.</li> <li>LearnCpp: An online resource offering free tutorials on various   aspects of C++ programming, from basics to advanced topics.</li> </ul>"},{"location":"lang/csharp/","title":"C# Style Guide","text":"<p>This guide specifically addresses C# development, focusing on idiomatic practices, patterns, and C#-specific considerations.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for C#.</p>"},{"location":"lang/csharp/#formatting","title":"Formatting","text":"<p>The formatting rules for C# adhere to our foundational formatting standards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/csharp/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for C# adhere to our foundational naming conventions:</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase for namespaces, concatenated words (avoid underscores).</li> </ul> <p>Example</p> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - Indentation: 2 spaces (C# standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style (opening brace on the same line as the statement).\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\npublic class WellFormattedCode { // (1)!\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an ArgumentOutOfRangeException if n is negative.\n   * @throws ArgumentOutOfRangeException If the provided number (n) is negative.\n   */\n  public static long CalculateFactorial(int n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw new ArgumentOutOfRangeException(nameof(n), \"Factorial is not defined for negative numbers.\");\n    }\n\n    long result = 1;\n    for (int i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol>"},{"location":"lang/csharp/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Refer to the Foundational Code Standards for general commenting and documentation guidelines.</p>"},{"location":"lang/csharp/#idioms-and-best-practices","title":"Idioms and Best Practices","text":"<p>C# offers a wealth of idiomatic practices and patterns that can make your code more concise, readable, and idiomatic. This section focuses on leveraging C#'s unique features effectively.</p>"},{"location":"lang/csharp/#properties-and-auto-properties","title":"Properties and Auto-Properties","text":"<p>Use properties and auto-properties to encapsulate fields and provide a clear, consistent interface to class and struct members.</p> <pre><code>public class Goat {\n    public string Name { get; set; }\n    public int Age { get; private set; }\n\n    public Goat(string name, int age) {\n        Name = name;\n        Age = age;\n    }\n}\n</code></pre>"},{"location":"lang/csharp/#linq-for-data-manipulation","title":"LINQ for Data Manipulation","text":"<p>Utilize Language Integrated Query (LINQ) for querying and manipulating collections in a declarative manner.</p> <pre><code>var adultGoats = goats.Where(goat =&gt; goat.Age &gt;= 2).ToList();\n</code></pre>"},{"location":"lang/csharp/#asyncawait-for-asynchronous-programming","title":"Async/Await for Asynchronous Programming","text":"<p>Employ async/await for managing asynchronous operations, improving responsiveness and scalability of your applications.</p> <pre><code>public async Task FeedAllGoatsAsync(IEnumerable&lt;Goat&gt; goats) {\n    foreach (var goat in goats) {\n        await goat.FeedAsync();\n    }\n}\n</code></pre>"},{"location":"lang/csharp/#expression-bodied-members","title":"Expression-bodied Members","text":"<p>Use expression-bodied members for single-line methods and properties.</p> <pre><code>public class Goat {\n    public string Name { get; }\n    public int Age { get; }\n\n    public Goat(string name, int age) =&gt; (Name, Age) = (name, age);\n\n    public void MakeSound() =&gt; Console.WriteLine($\"{Name} says 'Meeeh'\");\n}\n</code></pre>"},{"location":"lang/csharp/#null-coalescing-and-null-conditional-operators","title":"Null-coalescing and Null-conditional Operators","text":"<p>Leverage null-coalescing (<code>??</code>) and null-conditional (<code>?.</code>) operators to simplify null checks and default value assignment.</p> <pre><code>public string GetGoatName(Goat goat) =&gt; goat?.Name ?? \"Unknown\";\n</code></pre>"},{"location":"lang/csharp/#pattern-matching","title":"Pattern Matching","text":"<p>Use pattern matching to simplify type checks and conditional logic.</p> <pre><code>public void FeedAnimal(object animal) {\n    if (animal is Goat goat) {\n        Console.WriteLine($\"Feeding {goat.Name}\");\n    }\n}\n</code></pre>"},{"location":"lang/csharp/#tools-and-resources","title":"Tools and Resources","text":"<p>Ensuring a consistent development environment and utilizing static analysis tools are crucial steps for maintaining high code quality in C# projects.</p>"},{"location":"lang/csharp/#recommended-static-analysis-tools-for-c","title":"Recommended Static Analysis Tools for C","text":"<p>Static analysis tools help identify potential issues early in the development process. For C#, several tools are particularly effective:</p> <ul> <li>Roslyn Analyzers: A set of analyzers that use the .NET Compiler Platform (\"Roslyn\")   to offer comprehensive code analysis for C#.</li> <li>StyleCop: A static code analysis tool that checks C#   code for conformance to StyleCop's coding standards.</li> <li>SonarLint for Visual Studio: Extends SonarLint's   capabilities to C#, offering code smells detection, bugs tracking, and code quality metrics.</li> </ul>"},{"location":"lang/csharp/#additional-resources","title":"Additional Resources","text":"<ul> <li>.NET Documentation: The official .NET   documentation, providing comprehensive information on C# language features, .NET libraries, and   best practices.</li> <li>C# Programming Guide:   Offers detailed guidance on C# programming concepts, language features, and application   development techniques.</li> <li>C# Corner: A community and educational site offering   articles, tutorials, and forums on C# programming and .NET development.</li> </ul>"},{"location":"lang/dart/","title":"Dart Style Guide","text":"<p>This guide offers comprehensive insights into writing idiomatic, clean, and maintainable Dart code, aligning with Dart's conventions and best practices.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Dart.</p>"},{"location":"lang/dart/#formatting","title":"Formatting","text":"<p>The formatting rules for Dart adhere to our foundational formatting standards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul>"},{"location":"lang/dart/#naming-conventions","title":"Naming Conventions","text":"<p>Dart employs specific naming conventions to enhance readability and maintain consistency:</p> <ul> <li>PascalCase for classes, enum types, and type parameters.</li> <li>snake_case for libraries, packages, directories, and source files.</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>camelCase for functions, variables, constants, and parameters.<ul> <li>Prefix global constants with a lowercase <code>k</code> before <code>CamelCase</code>.</li> </ul> </li> </ul> <p>Example</p> <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation (Dart standard).\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n  /**\n   * This method calculates the factorial of a given positive integer.\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return The factorial of n, or throws an ArgumentError if n is negative.\n   * @throws ArgumentError If the provided number (n) is negative.\n   */\n  int calculateFactorial(int n) { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw ArgumentError('Factorial is not defined for negative numbers.');\n    }\n\n    int result = 1;\n    for (int i = 2; i &lt;= n; i++) { // (4)!\n      result *= i;\n    }\n    return result;\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol>"},{"location":"lang/dart/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/dart/#dartdoc","title":"DartDoc","text":"<p>Use DartDoc to document public APIs. Comments should be clear and concise, providing valuable insights into the code's purpose and usage.</p>"},{"location":"lang/dart/#inline-comments","title":"Inline Comments","text":"<ul> <li> <p>Use Sparingly: Inline comments should clarify complex algorithms, decisions not immediately   obvious, or provide context not readily apparent from the code itself.</p> Avoid excessive or obvious comments<pre><code>// Avoid excessive or obvious comments\n// Increment goatCount by 1\ngoatCount += 1;\n</code></pre> </li> </ul>"},{"location":"lang/dart/#documentation-comments","title":"Documentation Comments","text":"<ul> <li> <p>Use <code>///</code> for Public APIs: Document classes, methods, variables, and parameters using   Dart\u2019s <code>///</code> syntax. This aids consumers of your code and supports Dart's documentation generation   tools.</p> <pre><code>/// Represents a goat in a farm management system.\n///\n/// Stores information about the goat's name and feeding status.\nclass Goat {\n  /// The name of the goat.\n  final String name;\n\n  /// Creates a [Goat] with the given [name].\n  Goat(this.name);\n}\n</code></pre> </li> <li> <p>Describe Parameters and Return Types: For methods and functions, describe each parameter and   the return type. Use square brackets <code>[]</code> around parameter names to link them within generated   docs.</p> <pre><code>/// Feeds a [goat] with the specified [food].\n///\n/// Returns `true` if the goat was fed successfully.\nbool feedGoat(Goat goat, String food) {\n  // Implementation\n}\n</code></pre> </li> </ul>"},{"location":"lang/dart/#keeping-comments-up-to-date","title":"Keeping Comments Up-to-Date","text":"<ul> <li>Reflect Code Changes: Ensure comments are updated with code changes. Outdated comments can   mislead and confuse, diminishing code quality.</li> </ul>"},{"location":"lang/dart/#todo-comments","title":"TODO Comments","text":"<ul> <li> <p>Track Future Enhancements with Ticket Numbers: Use <code>TODO:</code> comments to mark areas of the code   requiring further work, including a brief description and a ticket number for tracking.</p> <pre><code>// TODO: [TICKET-123] Implement the feed scheduling logic\nvoid scheduleFeeding() {}\n</code></pre> </li> </ul>"},{"location":"lang/dart/#avoid-commented-out-code","title":"Avoid Commented-Out Code","text":"<ul> <li> <p>Remove, Don\u2019t Comment-Out: Commented-out code can clutter your codebase. Remove code that's no   longer needed or store it elsewhere if it might be useful later.</p> Good<pre><code>// Removed outdated goat feeding algorithm\n</code></pre> Avoid<pre><code>// Avoid leaving commented-out code\n// feedGoat(goat, \"Hay\");\n// console.log(\"Feeding completed\");\n</code></pre> </li> </ul>"},{"location":"lang/dart/#idioms-and-best-practices","title":"Idioms and Best Practices","text":""},{"location":"lang/dart/#effective-dart-guidelines","title":"Effective Dart Guidelines","text":"<p>Adhere to the Effective Dart Guidelines for tips on writing clear, idiomatic Dart code.</p>"},{"location":"lang/dart/#error-handling","title":"Error Handling","text":"<ul> <li> <p>Use <code>try-catch</code> for Exception Handling: Leverage Dart's exception handling features to   gracefully handle errors and exceptions. Provide clear feedback or recovery options when possible.</p> <p>Good<pre><code>try {\n  final goat = findGoatByName('Billy');\n  goat.feed();\n} catch (e) {\n  print('Failed to feed goat: $e');\n}\n</code></pre> Avoid ignoring exceptions<pre><code>try {\n  final goat = findGoatByName('Billy');\n  goat.feed();\n} catch (e) {\n  // Silent catch\n}\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#type-annotations","title":"Type Annotations","text":"<ul> <li> <p>Prefer Type Annotations in Public APIs: While Dart supports type inference, explicitly   annotating types in public APIs and complex code enhances clarity and ensures that your intentions   are clear.</p> <p>Good<pre><code>// Good\nvoid feedGoat(Goat goat) {\n  // Implementation\n}\n</code></pre> Avoid in public APIs<pre><code>// Avoid in public APIs\nvar feedGoat = (Goat goat) {\n  // Implementation\n};\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#immutable-collections","title":"Immutable Collections","text":"<ul> <li> <p>Favor Immutability for Collections: When collections are not meant to change, use Dart\u2019s   built-in support for immutable collections to prevent accidental or unintended modifications.</p> <p>Good<pre><code>final List&lt;Goat&gt; goats = const [Goat(name: 'Billy'), Goat(name: 'Daisy')];\n</code></pre> Avoid<pre><code>List&lt;Goat&gt; goats = [Goat(name: 'Billy'), Goat(name: 'Daisy')]; // Mutable\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#avoiding-global-mutable-state","title":"Avoiding Global Mutable State","text":"<ul> <li> <p>Minimize Use of Global State: Global mutable state can lead to code that is hard to reason   about and debug. Prefer passing objects explicitly through function parameters or using dependency   injection.</p> <p>Good<pre><code>class GoatFeeder {\n  final GoatPen _goatPen;\n\n  GoatFeeder(this._goatPen);\n\n  void feedAll() {\n    // Implementation\n  }\n}\n</code></pre> Avoid<pre><code>GoatPen globalGoatPen = GoatPen();\n\nvoid feedAllGoats() {\n  // Implementation using globalGoatPen\n}\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#using-final-and-const","title":"Using <code>final</code> and <code>const</code>","text":"<ul> <li> <p>Prefer <code>final</code> and <code>const</code> Where Possible: Use <code>final</code> for variables that you only want to   assign once, and <code>const</code> for compile-time constants. This practice enhances the predictability and   safety of your code.</p> Good<pre><code>final goatName = 'Billy';\nconst maxGoatsAllowed = 10;\n` ``\n```{.dart .bad-code title=\"Avoid unnecessary mutability\"}\nvar goatName = 'Billy'; // Could be final\n</code></pre> </li> </ul>"},{"location":"lang/dart/#asynchronous-programming","title":"Asynchronous Programming","text":"<ul> <li> <p>Embrace Asynchronous Programming: Dart\u2019s <code>async</code> and <code>await</code> keywords facilitate writing   asynchronous code that is clean, straightforward, and maintainable.</p> <p>Good<pre><code>Future&lt;void&gt; feedAllGoats() async {\n  final goats = await fetchGoats();\n  await Future.wait(goats.map((goat) =&gt; goat.feed()));\n}\n</code></pre> Avoid nested callbacks<pre><code>void feedAllGoats() {\n  fetchGoats().then((goats) {\n    for (final goat in goats) {\n      goat.feed().then((_) {\n        // Nested callback\n      });\n    }\n  });\n}\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#leveraging-extensions","title":"Leveraging Extensions","text":"<ul> <li> <p>Use Extensions to Add Functionality: Dart\u2019s extension methods allow you to add functionality   to existing classes without modifying them or creating subclasses, keeping your codebase flexible   and clean.</p> <pre><code>extension GoatExtensions on Goat {\n  void feedAndClean() {\n    feed();\n    clean();\n  }\n}\n\n// Usage\nfinal billy = Goat(name: 'Billy');\nbilly.feedAndClean();\n</code></pre> </li> </ul>"},{"location":"lang/dart/#leveraging-null-safety","title":"Leveraging Null Safety","text":"<ul> <li> <p>Make Use of Null Safety Features: Dart\u2019s sound null safety is designed to eliminate null   dereference errors. Use nullable types (<code>?</code>) and default values to ensure your code is more   predictable and safe.</p> <p>Good<pre><code>String? getGoatName(Goat? goat) =&gt; goat?.name;\n</code></pre> Avoid<pre><code>String getGoatName(Goat goat) =&gt; goat.name; // Unsafe if 'goat' is null\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#effective-use-of-collections","title":"Effective Use of Collections","text":"<ul> <li> <p>Utilize Collection Literals: Dart supports list, map, and set literals. Use these for creating   collections more succinctly and readably.</p> <p>Good<pre><code>// Good\nfinal goats = ['Billy', 'Daisy'];\nfinal goatAges = {'Billy': 2, 'Daisy': 3};\n</code></pre> Avoid<pre><code>final goats = List&lt;String&gt;.from(['Billy', 'Daisy']);\nfinal goatAges = Map&lt;String, int&gt;.from({'Billy': 2, 'Daisy': 3});\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#functional-programming-patterns","title":"Functional Programming Patterns","text":"<ul> <li> <p>Embrace Functional Programming Constructs: Take advantage of Dart\u2019s support for first-class   functions and higher-order functions to write cleaner and more expressive code.</p> <p>Good<pre><code>goats.forEach((goat) =&gt; print(goat));\nfinal adultGoats = goats.where((goat) =&gt; goat.age &gt; 1).toList();\n</code></pre> Avoid traditional for loops for simple iterations<pre><code>for (var goat in goats) {\n  print(goat);\n}\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#extension-methods","title":"Extension Methods","text":"<ul> <li> <p>Extend Existing Classes: Use extension methods to add functionality to existing classes   without modifying them or creating subclasses, keeping your codebase flexible and modular.</p> Good<pre><code>extension GoatExtensions on Goat {\n  bool get isAdult =&gt; age &gt; 1;\n}\n\n// Usage\nif (goat.isAdult) {\n  print('Goat is an adult');\n}\n</code></pre> </li> </ul>"},{"location":"lang/dart/#cascades","title":"Cascades","text":"<ul> <li> <p>Use Cascades to Chain Operations: Dart\u2019s cascade (<code>..</code>) operator allows you to perform a   sequence of operations on the same object. This can make your code more fluent and less verbose.</p> <p>Good<pre><code>final goatPen = GoatPen()\n  ..add(Goat(name: 'Billy'))\n  ..add(Goat(name: 'Daisy'))\n  ..close();\n</code></pre> Avoid<pre><code>final goatPen = GoatPen();\ngoatPen.add(Goat(name: 'Billy'));\ngoatPen.add(Goat(name: 'Daisy'));\ngoatPen.close();\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#asynchronous-programming_1","title":"Asynchronous Programming","text":"<ul> <li> <p>Prefer async/await Over Futures: Use <code>async</code> and <code>await</code> for handling asynchronous operations   to write code that is clean, simple, and easy to understand.</p> <p>Good<pre><code>Future&lt;void&gt; feedAllGoats() async {\n  final goats = await fetchGoats();\n  for (var goat in goats) {\n    await goat.feed();\n  }\n}\n</code></pre> Avoid using then() for complex chains of futures<pre><code>fetchGoats().then((goats) {\n  goats.forEach((goat) {\n    goat.feed().then((_) {\n      // Nested then()\n    });\n  });\n});\n</code></pre></p> </li> </ul>"},{"location":"lang/dart/#using-generics","title":"Using Generics","text":"<ul> <li>Generics for Type Safety and Flexibility: Use generics to write flexible and reusable code</li> <li> <p>components while maintaining type safety.</p> <pre><code>class GoatList&lt;T extends Goat&gt; {\n  final List&lt;T&gt; _goats = [];\n\n  void add(T goat) =&gt; _goats.add(goat);\n  List&lt;T&gt; get all =&gt; _goats;\n}\n\n// Usage\nfinal myGoats = GoatList&lt;Goat&gt;();\nmyGoats.add(Goat(name: 'Billy'));\n</code></pre> </li> </ul> <p>Adopting these Dart-specific idioms and patterns not only enhances code readability and efficiency but also ensures that your Dart codebase is robust, maintainable, and idiomatic. This approach leverages Dart\u2019s full potential to create high-quality applications.</p>"},{"location":"lang/dart/#tools-and-resources","title":"Tools and Resources","text":"<p>Setting up a productive development environment is crucial for Dart developers. This section guides on configuring tools and Integrated Development Environments (IDEs) to enhance productivity, ensure code quality, and align with Dart style guidelines.</p>"},{"location":"lang/dart/#ide-support","title":"IDE Support","text":""},{"location":"lang/dart/#visual-studio-code-vs-code","title":"Visual Studio Code (VS Code)","text":"<ul> <li> <p>Extensions: Install the Dart and Flutter (if using Flutter) extensions from the VS Code   marketplace to get syntax highlighting, code completion, and debug support.</p> </li> <li> <p>Format on Save: Enable \"Format On Save\" to automatically format your code according to Dart's   formatting rules. Go to Settings \u2192 search for \"Format On Save\" \u2192 check the box.</p> </li> <li> <p>Problem View: Use the Problems tab to quickly navigate and address issues identified by the   Dart analyzer.</p> </li> </ul>"},{"location":"lang/dart/#intellij-idea-android-studio","title":"IntelliJ IDEA / Android Studio","text":"<ul> <li> <p>Dart and Flutter Plugins: Install the Dart and Flutter plugins via Preferences \u2192 Plugins.   These provide comprehensive Dart support, including syntax highlighting, code completion, and   debugging.</p> </li> <li> <p>Code Style Configuration: Configure Dart formatting in Preferences \u2192 Editor \u2192 Code Style \u2192   Dart. You can adjust settings to match your team\u2019s style guide.</p> </li> <li> <p>Dart Analysis: Use the Dart Analysis window to view and navigate to issues in your codebase.   Customize analysis options with <code>analysis_options.yaml</code>.</p> </li> </ul>"},{"location":"lang/dart/#formatting-tools","title":"Formatting Tools","text":"<ul> <li>dart format: Use the <code>dart format</code> command to automatically format your Dart code. Integrate   this command into your version control pre-commit hooks to ensure consistent formatting.</li> </ul>"},{"location":"lang/dart/#linting","title":"Linting","text":"<ul> <li>Effective Dart: Use the linter package to enforce Dart best practices. Customize   your <code>analysis_options.yaml</code> to enable preferred lint rules.</li> </ul> <pre><code>include: package:lints/recommended.yaml\n</code></pre>"},{"location":"lang/dart/#dependency-management","title":"Dependency Management","text":"<ul> <li>Pub: Use Dart\u2019s package manager, pub, to manage dependencies. Regularly update your   dependencies to get the latest features and security updates.</li> </ul> <pre><code>dart pub upgrade\n</code></pre>"},{"location":"lang/dart/#dartfmt","title":"dartfmt","text":"<p>Utilize <code>dartfmt</code> to automatically format your code, ensuring consistency with Dart's style guide.</p>"},{"location":"lang/dart/#dart-analyzer","title":"Dart Analyzer","text":"<p>Use the Dart Analyzer to identify potential code issues, including syntax errors, type issues, and deprecated API usage.</p>"},{"location":"lang/dart/#linter","title":"Linter","text":"<p>Incorporate Dart Linter in your project to detect additional stylistic discrepancies and potential problems.</p>"},{"location":"lang/dart/#additional-resources","title":"Additional Resources","text":"<ul> <li>Dart Language Tour: Offers a comprehensive overview of Dart's features and   syntax.</li> <li>Dart Effective Dart: Provides a set of guides for styling, authoring, and using   Dart effectively.</li> </ul>"},{"location":"lang/go/","title":"Go Style Guide","text":"<p>This document outlines best practices and coding conventions for Go (Golang), aiming to foster code that is clean, readable, maintainable, and idiomatic to the Go programming language.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Go.</p>"},{"location":"lang/go/#formatting","title":"Formatting","text":"<p>While our foundational formatting standards provide comprehensive formatting guidelines, you should also use <code>gofmt</code> to ensure consistency across all Go code.</p> <ul> <li>Indentation: <code>gofmt</code> uses tabs for indentation. Do not use spaces.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Braces: Opening braces are placed on the same line.</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul>"},{"location":"lang/go/#naming-conventions","title":"Naming Conventions","text":"<p>Adhere to the foundational naming conventions:</p> <ul> <li>PascalCase for classes, protocols, and enumeration types</li> <li>camelCase for methods, variables, and properties.</li> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul> <p>In addition, adhere to Go's naming convention recommendations:</p> <ul> <li>Local Variables: Short, but descriptive names. Single letter names are common for small scopes</li> <li>Acronyms: Keep acronyms in uppercase. For example, use <code>HTTPRequest</code> instead of <code>HttpRequest</code>.</li> <li>Exported Identifiers: Start with an uppercase letter to make them public.</li> <li>Receiver Names: Keep receiver variable names short and consistent across methods.</li> </ul>"},{"location":"lang/go/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/go/#godoc","title":"Godoc","text":"<p>Godoc comments should precede package and public declarations. They should be complete sentences that describe the purpose and usage of the package or identifier.</p> Example<pre><code>// Package goatyacademy offers a collection of tutorials and exercises for goats\n// learning programming. It includes lessons on Go basics, debugging techniques,\n// and advanced concepts like concurrency. Exported functions support interactive\n// learning and progress tracking.\n</code></pre>"},{"location":"lang/go/#inline-comments","title":"Inline Comments","text":"<p>Inline comments should be used sparingly, only when necessary to explain complex logic or decisions that aren't obvious.</p>"},{"location":"lang/go/#api-documentation","title":"API Documentation","text":"<ul> <li>Consider using tools like Swagger to generate API documentation if your Go   program exposes functionalities through an API.</li> <li>This documentation should clearly explain API endpoints, request parameters, response formats, and   error handling mechanisms.</li> </ul>"},{"location":"lang/go/#idioms-and-best-practices","title":"Idioms and Best Practices","text":""},{"location":"lang/go/#pointers","title":"Pointers","text":"<p>Use pointers to modify an original value or to avoid copying large structures. However, use them judiciously as they can complicate the code's understanding.</p> Example<pre><code>package main\n\nimport \"fmt\"\n\n// Goat represents a character in the game.\ntype Goat struct {\n    Name  string\n    Score int\n}\n\n// IncreaseScore increases the score of a Goat by the given number of points.\n// The Goat's score is modified in place using a pointer receiver.\nfunc IncreaseScore(g *Goat, points int) {\n    g.Score += points\n}\n\nfunc main() {\n    billy := Goat{Name: \"Billy\", Score: 10}\n    IncreaseScore(&amp;billy, 5) // Demonstrates how to use a pointer receiver to modify a struct's field.\n    fmt.Printf(\"%s's new score: %d\\n\", billy.Name, billy.Score)\n}\n</code></pre>"},{"location":"lang/go/#goroutines-and-channels","title":"Goroutines and Channels","text":"<p>Embrace Go's concurrency model using goroutines and channels for parallel execution paths. Keep synchronization and data sharing simple to maintain readability and performance.</p> Example<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// sendMessage simulates sending a message through a channel.\nfunc sendMessage(ch chan&lt;- string, message string) {\n    time.Sleep(2 * time.Second) // Simulate delay.\n    ch &lt;- message\n}\n\nfunc main() {\n    messageChannel := make(chan string)\n    go sendMessage(messageChannel, \"Lesson 1 completed\")\n    message := &lt;-messageChannel\n    fmt.Println(\"Received:\", message)\n}\n</code></pre>"},{"location":"lang/go/#interfaces","title":"Interfaces","text":"<p>Define small, focused interfaces, preferably with one or two methods. This approach promotes modular design and flexible integration of components.</p> Example<pre><code>package main\n\nimport \"fmt\"\n\n// Edible defines behavior for food items that can be consumed by goats.\ntype Edible interface {\n    Eat()\n}\n\n// Hay is a type of food that can be eaten by goats.\ntype Hay struct{}\n\nfunc (h Hay) Eat() {\n    fmt.Println(\"Hay is being eaten.\")\n}\n\n// Treat is another type of food for goats.\ntype Treat struct{}\n\nfunc (t Treat) Eat() {\n    fmt.Println(\"Treat is being eaten.\")\n}\n\nfunc feedGoat(e Edible) {\n    e.Eat()\n}\n\nfunc main() {\n    hay := Hay{}\n    treat := Treat{}\n\n    feedGoat(hay)\n    feedGoat(treat)\n}\n</code></pre>"},{"location":"lang/go/#error-handling-with-defer","title":"Error Handling with <code>defer</code>","text":"<ul> <li>The <code>defer</code> statement allows you to execute a function after the surrounding function finishes (   regardless of normal execution or errors). Utilize <code>defer</code> to ensure resources are properly closed   or cleanup tasks are performed even if errors occur.</li> </ul> <p>Example:</p> Example<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\n// processOrder simulates processing an order and uses defer for cleanup.\nfunc processOrder(filename string) error {\n    f, err := os.Open(filename)\n    if err != nil {\n        return err\n    }\n    defer f.Close() // Ensure the file is closed even if an error occurs.\n\n    // Process the order here.\n    fmt.Println(\"Processing order from\", filename)\n    return nil\n}\n\nfunc main() {\n    err := processOrder(\"order.txt\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre>"},{"location":"lang/go/#slices-and-maps","title":"Slices and Maps","text":"<ul> <li>Go offers slices (dynamically sized arrays) and maps (key-value pairs) for efficient data storage   and retrieval. Utilize slices to manage collections of goats within your herd and maps for storing   goat attributes that might not be common to all (e.g., favorite toys).</li> </ul> Example<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Slice of goat names attending the disco.\n    goatNames := []string{\"Billy\", \"Daisy\", \"Ginny\"}\n\n    // Map to store each goat's favorite dance move.\n    favoriteMoves := map[string]string{\n        \"Billy\": \"Twist\",\n        \"Daisy\": \"Shuffle\",\n        \"Ginny\": \"Spin\",\n    }\n\n    for _, name := range goatNames {\n        fmt.Printf(\"%s's favorite move: %s\\n\", name, favoriteMoves[name])\n    }\n}\n</code></pre>"},{"location":"lang/go/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/go/#essential-tools","title":"Essential Tools","text":"<ul> <li>Go Toolchain The Go toolchain, including the <code>go</code> command, is   essential for compiling, running, and testing your Go programs.</li> <li>GoLand: A commercial IDE by JetBrains specifically designed   for Go development. It offers advanced features like code completion, refactoring, debugging, and   integration with various testing frameworks.</li> <li>Visual Studio Code (VS Code): A free, open-source code   editor by Microsoft with extensive customization options and support for various programming   languages, including Go. You can install extensions like Go extension pack to enhance Go   development functionalities within VS Code.</li> </ul>"},{"location":"lang/go/#static-analysis-tools","title":"Static Analysis Tools","text":"<ul> <li>Staticcheck is a static analysis tool that helps you write better   Go code by flagging errors, bugs, stylistic issues, and simplifications.</li> </ul>"},{"location":"lang/go/#additional-resources","title":"Additional Resources","text":"<ul> <li>Effective Go: Offers tips for writing clear, idiomatic   Go code.</li> <li>Go Code Review Comments: A collection of   common comments made during reviews of Go code.</li> </ul>"},{"location":"lang/java/","title":"Java Style Guide","text":"<p>This guide outlines best practices for writing clean, consistent, and understandable Java code, focusing on readability, maintainability, and idiomatic usage.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Java.</p>"},{"location":"lang/java/#formatting","title":"Formatting","text":"<p>The formatting guidelines for Kotlin adhere to our Foundational Code Standards. Here is a brief overview:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/java/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Kotlin adhere to our Foundational Code Standards with no exceptions.</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul>"},{"location":"lang/java/#documentation-and-comments","title":"Documentation and Comments","text":""},{"location":"lang/java/#commenting-code","title":"Commenting Code","text":"<ul> <li>Purpose and Clarity: Comments should clarify the purpose of the code, covering \"why\" it does   something, not just \"what\" it does. Avoid redundant comments.</li> <li> <p>Keep Comments Updated: As code changes, ensure comments are updated to reflect current   functionality. Outdated comments can be more misleading than no comments at all.</p> <pre><code>// Correct use of comments to explain the \"why\"\n// Adjusts goat happiness level based on feeding time; longer feeding times make happier goats.\ngoat.adjustHappiness(feedingTimeMinutes *HAPPINESS_FACTOR);\n</code></pre> </li> </ul>"},{"location":"lang/java/#documentation-comments","title":"Documentation Comments","text":"<ul> <li>Classes and Interfaces: Provide a summary at the beginning of each class and interface,   describing its purpose and role within the application.</li> <li>Methods: Document every method, including a description of its behavior, parameters, return   values, and any exceptions thrown.</li> <li> <p>JavaDoc Conventions: Use JavaDoc standard tags (<code>@param</code>, <code>@return</code>, <code>@throws</code>) to describe   method signatures. Inline <code>{@code}</code> for code references and <code>{@link}</code> for related classes or   methods.</p> Example<pre><code>/**\n * Represents a goat in the farm simulation.\n * &lt;p&gt;\n * This class provides methods to manage the goat's state, including its hunger and happiness levels.\n */\npublic class Goat {\n  private final String name;\n  private final int age;\n\n  /**\n   * Constructs a new Goat with the specified name and age.\n   *\n   * @param name the name of the goat\n   * @param age the age of the goat\n   */\n  public Goat(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  /**\n   * Feeds the goat, adjusting its hunger level.\n   *\n   * @param foodType The type of food being fed to the goat.\n   * @param quantity The amount of food in kilograms.\n   * @return The health status after feeding.\n   * @throws OverfeedingException If the quantity of food exceeds the goat's dietary restrictions.\n   */\n  public String feed(String foodType, double quantity) throws OverfeedingException {\n    // Implementation omitted\n    return \"Healthy\";\n  }\n}\n</code></pre> </li> </ul>"},{"location":"lang/java/#inline-comments","title":"Inline Comments","text":"<ul> <li>Use Sparingly: Inline comments are intended for complex code segments where the logic's   purpose or action isn't immediately clear from the code itself.</li> <li> <p>Location: Place inline comments on the line above the code segment they describe, not at the   end of the line of code.</p> <pre><code>// Calculate the optimal feeding time based on the goat's current activity level\nint feedingTime = calculateFeedingTime(goat.getActivityLevel());\n</code></pre> </li> </ul>"},{"location":"lang/java/#documentation-for-public-apis","title":"Documentation for Public APIs","text":"<ul> <li>Comprehensive Coverage: Every public class, method, and member variable should be documented,   offering clear insights into the component's purpose, use, and behavior. Documentation should be   precise and comprehensive, especially for software that may be used in critical systems. Consider   the principles of security, reliability, and transparency in your documentation practices.</li> </ul>"},{"location":"lang/java/#todos-and-fixmes","title":"TODOs and FIXMEs","text":"<ul> <li>Ticket-Based Tracking Preferred: While <code>TODO:</code> and <code>FIXME:</code> comments can highlight areas   needing attention or improvement within the codebase, utilizing a ticket-based tracking system is   preferred for managing tasks and issues. This approach facilitates better prioritization,   tracking, and resolution of tasks.</li> <li> <p>Include Ticket Numbers: When using <code>TODO:</code> or <code>FIXME:</code> comments, always include the   corresponding ticket number from your project's issue tracking system. This practice links code   comments directly to detailed descriptions, discussions, and updates on the issue or task at hand,   ensuring actionable and trackable comments.</p> <pre><code>// TODO: [TICKET-1234] Implement happiness adjustment based on the current weather conditions\n// FIXME: [TICKET-5678] Resolve issue where feeding time exceeds 24 hours in edge cases\n</code></pre> </li> </ul>"},{"location":"lang/java/#best-practices-and-idioms","title":"Best Practices and Idioms","text":""},{"location":"lang/java/#error-handling","title":"Error Handling","text":"<ul> <li>Prefer Exceptions to Return Codes: Use exceptions to indicate errors or exceptional   conditions. This approach avoids cluttering your code with error handling and makes error paths   clear.</li> <li>Catch Specific Exceptions: Whenever possible, catch the most specific exception type rather   than generic ones like <code>Exception</code> or <code>Throwable</code>.</li> <li>Throw Specific Exceptions: Throw exceptions that accurately represent the error condition.   Custom exception types can be defined to provide more detailed error information.</li> <li> <p>Resource Handling: Use try-with-resources statements for resource management to ensure that   resources are closed properly and efficiently.</p> Example<pre><code>try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    return br.readLine();\n} catch (IOException e) {\n    throw new MySpecificException(\"Failed to read from file: \" + path, e);\n}\n</code></pre> </li> </ul>"},{"location":"lang/java/#control-structures","title":"Control Structures","text":"<ul> <li>Consistent Bracing: Use the \"Egyptian style\" for braces where the opening brace is at the end   of the line that begins the block, and the closing brace is aligned with the start of the line   that begins the block.</li> <li>No Empty Loops or Ifs: Avoid empty loop bodies or <code>if</code> statements; use comments to explain the   reasoning if necessary.</li> </ul>"},{"location":"lang/java/#class-method-and-modifier-organization","title":"Class, Method, and Modifier Organization","text":"<ul> <li>Class Member Ordering: Logical or temporal grouping should guide the ordering of class   members. Typically, variables should be declared at the top of the class, followed by constructors   and methods. Similar functions should be grouped together or placed in a logical sequence.</li> <li>Method Length: Keep methods short and focused. A method should represent a single logical   operation or action. If a method grows too large, consider breaking it into smaller helper   methods.</li> <li> <p>Modifiers: Use the Java Language Specification (JLS) recommended order of   modifiers: <code>public</code>, <code>protected</code>, <code>private</code>, <code>abstract</code>, <code>static</code>, <code>final</code>, <code>transient</code>,    <code>volatile</code>, <code>synchronized</code>, <code>native</code>, <code>strictfp</code>.</p> Example<pre><code>public static final synchronized void petGoat() {\n  // Method body\n}\n</code></pre> </li> </ul>"},{"location":"lang/java/#switch-statements","title":"Switch Statements","text":"<ul> <li>Fall-through: Mark intentional fall-throughs with a comment to distinguish them from   missing <code>break</code> statements.</li> <li> <p>Default Case: Always include a <code>default</code> case in switch statements, even if it simply throws   an exception. This ensures that all possibilities are explicitly handled.</p> \ud83c\udf3f Example<pre><code>public void chooseMarijuanaType(String desiredEffect) {\n  String strainType;\n  switch (desiredEffect) {\n    case \"relax\":\n      strainType = \"Indica\";\n      break;\n    case \"energize\":\n      strainType = \"Sativa\";\n      break;\n    case \"balance\":\n      // fall-through: Suitable for both relaxation and energy\n    case \"meditate\":\n      strainType = \"Hybrid\";\n      break;\n    default:\n      throw new IllegalArgumentException(\"Effect not recognized\");\n  }\n  System.out.println(\"Recommended strain type: \" + strainType);\n}\n</code></pre> </li> </ul>"},{"location":"lang/java/#language-specific-idioms-and-patterns","title":"Language-Specific Idioms and Patterns","text":"<p>Adhering to Java's idiomatic patterns enhances code readability, efficiency, and maintainability, crucial for both Android and other Java environments. This section emphasizes best practices that are compatible across various Java versions.</p>"},{"location":"lang/java/#effective-use-of-collections","title":"Effective Use of Collections","text":"<p>Leverage standard Java Collections Framework effectively. Opt for the appropriate interface (e.g., <code>List</code>, <code>Set</code>, <code>Map</code>) to convey the collection's characteristics and intended use.</p> \ud83d\udc10 Example<pre><code>// List for ordered collection with duplicates allowed\nList&lt;Goat&gt; goatHerd = new ArrayList&lt;&gt;();\n// Set for a unique collection, no duplicates\nSet&lt;Goat&gt; uniqueGoats = new HashSet&lt;&gt;();\n</code></pre>"},{"location":"lang/java/#using-interfaces-for-type-definitions","title":"Using Interfaces for Type Definitions","text":"<p>Prefer using interface types (e.g., <code>List</code>, <code>Map</code>) in variable declarations, method returns, and parameters. This approach increases flexibility by decoupling the code from specific implementations.</p>"},{"location":"lang/java/#consistent-error-handling","title":"Consistent Error Handling","text":"<p>Use exceptions to handle errors. Define custom exception classes when you need to convey specific error information. Catch exceptions at a level where you can handle them meaningfully.</p> Example<pre><code>try {\n  feedGoats(goatHerd);\n} catch (InsufficientFoodException e) {\n  log.error(\"Not enough food for the goats\", e);\n  // Handle error gracefully\n}\n</code></pre>"},{"location":"lang/java/#avoiding-magic-numbers","title":"Avoiding Magic Numbers","text":"<p>Replace magic numbers with named constants to improve code readability and maintainability.</p> Example<pre><code>public class GoatFeeder {\n  private static final int MAX_FEED_PER_GOAT_KG = 5;\n\n  public void feedGoat(Goat goat, int feedKg) {\n    if (feedKg &gt; MAX_FEED_PER_GOAT_KG) {\n      throw new IllegalArgumentException(\"Too much feed for one goat\");\n    }\n    // Feed the goat\n  }\n}\n</code></pre>"},{"location":"lang/java/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/java/#static-analysis-tools","title":"Static Analysis Tools","text":"<ul> <li>Checkstyle: Ensures that the code adheres to a coding standard, helping maintain consistency across the project.</li> <li>PMD: Scans code for potential bugs, unused variables, unnecessary object creation, and more.</li> <li>SpotBugs: Focuses on identifying potential bugs in code through bytecode analysis.</li> <li>SonarQube: Provides a comprehensive overview of code quality, highlighting bugs, vulnerabilities, and code smells. It also offers detailed code metrics and history.</li> <li>JaCoCo: Offers code coverage analysis to ensure that your tests cover a significant portion of your codebase.</li> </ul>"},{"location":"lang/java/#additional-resources","title":"Additional Resources","text":"<ul> <li>Oracle's Java Tutorials: Comprehensive tutorials on Java programming   language features and libraries.</li> <li>Effective Java: A book by Joshua Bloch, providing best practices for writing   effective Java code.</li> </ul>"},{"location":"lang/javascript/","title":"JavaScript Style Guide","text":"<p>This guide focuses on best practices and conventions for writing clean, understandable, and maintainable JavaScript code. It emphasizes adherence to contemporary JavaScript standards and practices while also incorporating unique aspects of JavaScript programming.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for JavaScript.</p>"},{"location":"lang/javascript/#formatting","title":"Formatting","text":"<p>The formatting guidelines for JavaScript adhere to our Foundational Code Standards. Here is a brief overview:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords for   clarity.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p> Formatted JavaScript Example Code <p>type: example</p> <pre><code>class Example {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  performOperations() {\n    const inner = new Inner();\n    inner.display();\n\n    const sum = this.x + this.y; // Space around operators\n    console.log(`Sum: ${sum}`);\n\n    // Ternary operator with spaces\n    const message = sum &gt; 10 ? 'Greater than 10' : 'Not greater than 10';\n    console.log(message);\n\n    // If-else with spacing and brace style\n    if (sum % 2 === 0) {\n      console.log('Sum is even');\n    } else {\n      console.log('Sum is odd');\n    }\n\n    // For loop demonstrating continuation indent\n    for (let i = 0; i &lt; 5; i++) {\n      process.stdout.write(`${i} `); // Demonstrate space in concatenation\n    }\n    console.log(); // New line after loop\n\n    // Try-catch-finally block\n    try {\n      throw new Error('Demo exception');\n    } catch (e) {\n      console.log(`Caught exception: ${e.message}`);\n    } finally {\n      console.log('Finally block executed');\n    }\n  }\n\n  // Inner class\n  static innerClass() {\n    class Inner {\n      display() {\n        console.log('Inside Inner class');\n      }\n    }\n\n    return Inner;\n  }\n}\n\n// Using the inner class functionality\nconst Inner = Example.innerClass();\n\nfunction main() {\n  const example = new Example(3, 7);\n  example.performOperations();\n}\n\nmain();\n</code></pre>"},{"location":"lang/javascript/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Kotlin adhere to our Foundational Code Standards with no exceptions.</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul>"},{"location":"lang/javascript/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/javascript/#inline-comments","title":"Inline Comments","text":"<ul> <li>Clarity: Use inline comments sparingly and only when they add significant value or   clarification to the code.</li> <li>Placement: Place inline comments on the same line as the statement they refer to, separated by   at least two spaces from the code, followed by a <code>#</code> and a single space before the comment text.</li> </ul> Example<pre><code>feed_time = True # Goats are fed at sunrise and sunset\n</code></pre>"},{"location":"lang/javascript/#jsdoc-for-documentation","title":"JSDoc for Documentation","text":"<p>Use JSDoc to document function signatures, class definitions, and module interfaces. This aids in understanding the structure and intended use of your code.</p>"},{"location":"lang/javascript/#use-verb-noun-naming-for-functions","title":"Use Verb-Noun Naming for Functions","text":"<ul> <li>Verb-Noun Pattern: Name functions starting with a verb that describes the action followed by a   noun indicating what the function acts upon. This convention clarifies the function's purpose.</li> </ul> <pre><code>function translateToGoat(message) {\n  const emojiDictionary = {\n    happy: '\ud83d\ude0a\ud83d\udc10',\n    food: '\ud83c\udf3f',\n    play: '\ud83d\udc3e\ud83d\udc10'\n  };\n  return message.split(' ').map(word =&gt; emojiDictionary[word] || word).join(' ');\n}\n</code></pre>"},{"location":"lang/javascript/#handling-acronyms","title":"Handling Acronyms","text":"<ul> <li>Capitalize Acronyms: When using acronyms in names, capitalize them if they are at the   beginning of the name. If the acronym is not at the start, only capitalize the first letter.</li> </ul> <pre><code>function decodeBLEGTMessage(blegtCode) {\n  // B.L.E.G.T: Binary Language Encoding for Goat Transmission\n  const bleatDictionary = {\n    '1100': 'baaaa',\n    '1010': 'maaaa',\n    '1111': 'baaa-bleet'\n  };\n\n  const message = bleatDictionary[blegtCode] || 'unknown transmission';\n  console.log(`Decoded B.L.E.G.T message: ${message}`);\n}\n\ndecodeBLEGTMessage('1100');\n</code></pre>"},{"location":"lang/javascript/#use-of-todo-and-fixme","title":"Use of TODO and FIXME","text":"<ul> <li>TODO for Future Actions: Utilize <code>TODO</code> comments to mark places in the code that require   future action, enhancement, or implementation. However, instead of leaving <code>TODO</code> comments as   vague reminders, link them directly to tickets in your project\u2019s issue tracking system whenever   possible. This approach ensures that the tasks are tracked, prioritized, and not forgotten.</li> </ul> <pre><code>// TODO: [Ticket #123] Implement dynamic playlist feature based on the current mood of goats\nfunction generateDynamicPlaylist(mood) {\n  console.log(`Generating playlist for ${mood} mood.`);\n}\n</code></pre> <ul> <li>FIXME for Immediate Issues: Use <code>FIXME</code> annotations to highlight code that needs immediate   attention due to bugs or significant issues affecting functionality. Like <code>TODO</code> comments,   associate <code>FIXME</code> notes with tickets in your tracking system to ensure they are addressed promptly   and not overlooked.</li> </ul> <pre><code>// FIXME: [Ticket #456] Resolve issue where hay allergies are not correctly filtering hay types\nfunction filterHayForAllergies(hayTypes, goatAllergies) {\n  // Current filtering logic omitted\n  console.log(\"Filtered hay based on allergies.\");\n}\n</code></pre>"},{"location":"lang/javascript/#preference-for-tickets","title":"Preference for Tickets","text":"<p>By referencing specific tickets in your project's issue or bug tracking system within <code>TODO</code> and <code>FIXME</code> comments, you create a reliable method for tracking these tasks beyond the codebase. This practice helps prevent tasks from being lost or ignored and facilitates better planning and prioritization in project management.</p>"},{"location":"lang/javascript/#idioms-and-best-practices","title":"Idioms and Best Practices","text":"<p>Understanding and utilizing JavaScript's unique idioms and patterns empowers developers to write more efficient, readable, and idiomatic code.</p>"},{"location":"lang/javascript/#arrow-functions","title":"Arrow Functions","text":"<ul> <li> <p>Arrow Functions and <code>this</code>: Use arrow functions for anonymous functions or when you need to   preserve the lexical value of <code>this</code>. They provide a concise syntax and are particularly useful   for callbacks.</p> <pre><code>const goatClass = {\n  students: ['Billy', 'Daisy', 'Goatee'],\n  className: 'Intro to Grazing',\n  printStudents() {\n    this.students.forEach(student =&gt; {\n      console.log(`${student} is enrolled in ${this.className}.`);\n    });\n  }\n};\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#consistent-use-of-const-and-let","title":"Consistent Use of <code>const</code> and <code>let</code>","text":"<ul> <li> <p>Immutable Variables: Prefer <code>const</code> for all variables that do not get reassigned after   initialization. Use <code>let</code> for variables that will change. This approach not only makes the code   more readable but also helps in identifying variables that are meant to be immutable.</p> <pre><code>const gameTitle = 'Goat Jump Adventure';\nlet currentLevel = 1;\n\nfunction advanceLevel() {\n  currentLevel += 1;\n  console.log(`Advanced to level ${currentLevel}`);\n}\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#error-handling","title":"Error Handling","text":"<ul> <li> <p>Try/Catch for Asynchronous Code: Utilize <code>try/catch</code> blocks within <code>async</code> functions to handle   errors gracefully. This ensures that errors in asynchronous operations do not go uncaught.</p> <pre><code>async function sendMessage(message) {\n  try {\n    await chatService.send(message);\n    console.log('Message sent successfully');\n  } catch (error) {\n    console.error('Failed to send message', error);\n  }\n}\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#function-purity","title":"Function Purity","text":"<ul> <li> <p>Pure Functions: Whenever possible, write functions that are pure. A pure function\u2019s output   should solely depend on its input, and it should not cause side effects. This makes your code more   predictable and easier to test.</p> <pre><code>// Calculates the next song to play based on the goat's current mood.\n// This is a pure function as it only depends on its input and has no side effects.\nfunction nextSong(mood) {\n  const moodToSong = {\n    happy: 'Barnyard Dance',\n    sad: 'Goat Blues',\n    energetic: 'Hoof Stomper'\n  };\n  return moodToSong[mood] || 'Chewin\\' on Grass';\n}\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#modular-code","title":"Modular Code","text":"<ul> <li> <p>Modularization: Break down your code into smaller, reusable modules or functions. This not   only helps in organizing the code better but also facilitates easier testing and debugging.</p> <pre><code>// Modular function to add a goat to the leaderboard\nfunction addToLeaderboard(leaderboard, goat) {\n  leaderboard.push(goat);\n  leaderboard.sort((a, b) =&gt; b.score - a.score);\n}\n\n// Modular function to display the leaderboard\nfunction displayLeaderboard(leaderboard) {\n  console.log('GOAT Leaderboard:');\n  leaderboard.forEach((goat, index) =&gt; {\n    console.log(`${index + 1}. ${goat.name} - ${goat.score}`);\n  });\n}\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#use-of-template-literals","title":"Use of Template Literals","text":"<ul> <li> <p>String Concatenation: Prefer template literals over string concatenation for readability,   especially when embedding variables or expressions within strings.</p> <pre><code>function logGoatMessage(name, message) {\n  console.log(`${name} says: ${message}`);\n}\n\nlogGoatMessage('Billy', 'Baaa baaa baaa');\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#asynchronous-programming","title":"Asynchronous Programming","text":"<ul> <li>Promises and Async/Await: Embrace the use of Promises and the async/await syntax for handling   asynchronous operations. This approach leads to cleaner, more readable code compared to   traditional callback patterns.</li> </ul>"},{"location":"lang/javascript/#destructuring-for-clarity","title":"Destructuring for Clarity","text":"<ul> <li> <p>Object and Array Destructuring: Embrace destructuring for its ability to extract multiple   properties from objects or arrays succinctly, improving code clarity, especially in function   parameters.</p> <pre><code>function prepareGoatMeal({name, favoriteSnack}) {\n  console.log(`Preparing ${favoriteSnack} for ${name}.`);\n}\n\nconst goatDetails = {\n  name: 'Buttercup',\n  favoriteSnack: 'Apples'\n};\n\nprepareGoatMeal(goatDetails);\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#template-literals-for-dynamic-strings","title":"Template Literals for Dynamic Strings","text":"<ul> <li> <p>Leverage Template Literals: Adopt template literals for constructing dynamic strings. Their   readability and support for expression interpolation and multi-line strings make them superior to   traditional string concatenation.</p> <pre><code>function createWelcomeMessage(user, message) {\n  return `Welcome ${user}! ${message}`;\n}\n\nconsole.log(createWelcomeMessage('BillyTheGoat', 'Ready to bleat-chat?'));\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#spread-and-rest-operators-for-flexible-collections","title":"Spread and Rest Operators for Flexible Collections","text":"<ul> <li> <p>Spread Operator for Collections: Use the spread operator (<code>...</code>) to elegantly combine arrays,   insert elements, or clone objects and arrays, thereby enhancing code flexibility and readability.</p> <pre><code>const initialGoats = ['Billy', 'Daisy'];\nconst newGoats = ['Ginny', 'Clover'];\n\nconst allGoats = [...initialGoats, ...newGoats];\nconsole.log(allGoats);\n</code></pre> <ul> <li>Rest Parameters for Indefinite Arguments: Utilize rest parameters to collect an indefinite   number of arguments into an array, simplifying the handling of function arguments.</li> </ul> <pre><code>function calculateTotalScores(...scores) {\n  return scores.reduce((total, score) =&gt; total + score, 0);\n}\n\nconsole.log(calculateTotalScores(50, 75, 100, 120));\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#tools-and-ide-setup","title":"Tools and IDE Setup","text":"<p>For JavaScript developers, configuring the right tools and Integrated Development Environment (IDE) setup is pivotal for enhancing productivity, ensuring code quality, and facilitating collaboration.</p>"},{"location":"lang/javascript/#integrated-development-environments-ides-and-editors","title":"Integrated Development Environments (IDEs) and Editors","text":"<ul> <li> <p>Visual Studio Code (VS Code): Highly recommended for   JavaScript development due to its extensive ecosystem of extensions, built-in terminal, and Git   integration. Install the ESLint extension to enforce style rules and Prettier for code formatting.</p> </li> <li> <p>WebStorm: A powerful IDE for JavaScript, offering   intelligent coding assistance, navigation tools, and advanced refactoring capabilities. WebStorm   includes built-in support for modern frameworks and testing tools.</p> </li> </ul>"},{"location":"lang/javascript/#linting-and-formatting-tools","title":"Linting and Formatting Tools","text":"<ul> <li> <p>ESLint: An indispensable tool for identifying and fixing   problems in JavaScript code. Integrate ESLint into your project to enforce coding standards and   catch errors early.</p> <pre><code>npm install eslint --save-dev npx eslint --init\n</code></pre> </li> <li> <p>Prettier is an opinionated code formatter that   supports many languages, including JavaScript. It enforces a consistent style by parsing your code   and reprinting it with its own rules.</p> <pre><code>npm install --save-dev --save-exact prettier\n</code></pre> </li> </ul>"},{"location":"lang/javascript/#package-management","title":"Package Management","text":"<ul> <li>npm or Yarn: Manage project dependencies and   scripts using a package manager like npm or Yarn. These tools are essential for managing   libraries, frameworks, and tools in your JavaScript project.</li> </ul>"},{"location":"lang/javascript/#task-runners-and-module-bundlers","title":"Task Runners and Module Bundlers","text":"<ul> <li> <p>Webpack: Bundle your JavaScript applications for   optimization and deployment. Webpack can transform and bundle assets, such as JavaScript, CSS, and   images.</p> </li> <li> <p>Babel: Use Babel to compile modern JavaScript code into   backwards compatible versions for   broader browser support.</p> </li> </ul>"},{"location":"lang/javascript/#additional-resources","title":"Additional Resources","text":"<ul> <li>Airbnb JavaScript Style Guide: A comprehensive guide   to writing cleaner JavaScript code.</li> <li>MDN Web Docs: An invaluable resource for learning about   JavaScript features, APIs, and best practices.</li> </ul>"},{"location":"lang/kotlin/","title":"Kotlin Style Guide","text":"<p>This guide specifically addresses Kotlin development, focusing on idiomatic practices, patterns, and Kotlin-specific considerations.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Kotlin.</p>"},{"location":"lang/kotlin/#formatting","title":"Formatting","text":"<p>Adhere to the foundational formatting stadards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords for   clarity.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li> <p>Alignment: Align elements in documentation comments and parameter lists.</p> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p> </li> </ul> Formatted Kotlin Example Code <pre><code>/**\n * This class demonstrates proper code formatting following the specified style guide.\n *\n * **Formatting Rules:**\n * - 2 spaces for indentation.\n * - 4 spaces for continuation lines.\n * - Max line length of 100 characters.\n * - Spaces around operators, control structures, and keywords.\n * - K&amp;R brace style.\n * - Consistent spacing for parameter lists and constructor arguments.\n * - Doc comments with aligned descriptions.\n */\nclass WellFormattedCode { // (1)!\n\n  /**\n   * This method calculates the factorial of a given positive integer. // Doc comment for method\n   *\n   * @param n The non-negative integer for which to calculate the factorial.\n   * @return  The factorial of n, or throws an IllegalArgumentException if n is negative.\n   * @throws IllegalArgumentException If the provided number (n) is negative.\n   */\n  fun calculateFactorial(n: Int): Long { // (2)!\n    if (n &lt; 0) { // (3)!\n      throw IllegalArgumentException(\"Factorial is not defined for negative numbers.\")\n    }\n\n    var result = 1L\n    for (i in 2..n) {  // (4)!\n      result *= i\n    }\n    return result\n  }\n}\n</code></pre> <ol> <li>Class name in PascalCase with a doc comment.</li> <li>Method name in camelCase with a doc comment.</li> <li>K&amp;R brace style for blocks.</li> <li>Proper spacing around operators and control structures.</li> </ol>"},{"location":"lang/kotlin/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Kotlin adhere to our foundational naming conventions with no exceptions.</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul> GoodBad Correct Usage<pre><code>// Class following PascalCase for a data definition\nclass Goat {\n    // Variable following camelCase for a property\n    var isHappy = true\n\n    // Function following camelCase with descriptive name\n    fun eatGrass(amount: Int) {\n        println(\"The goat munches on $amount kg of grass\")\n    }\n\n    // Function with UPPER_SNAKE_CASE for a constant\n    companion object {\n        const val MAX_SPEED = 40 // km/h\n    }\n}\n</code></pre> Incorrect Usage<pre><code>// Inconsistent naming (should be Goat)\nclass goat {\n\n  // Unclear variable name\n  var happy = true\n\n  // Unnecessary abbreviation in function name\n  fun eat(amt: Int) {\n    println(\"The goat munches on $amt kg of grass\") // Should use descriptive variable 'amount'\n  }\n\n  // Unclear function name\n  fun isHealthy(g: goat): String {\n    val msg = if (g.happy) {\n      \"Goat happy!\"\n    } else {\n      \"Goat might be sick!\"\n    }\n    return msg\n  }\n\n  companion object {\n    // should be UPPER_SNAKE_CASE\n    const val maxSpeed = 40 // km/h\n  }\n}\n\n// Mixed naming convention (should be snake_case or camelCase)\nfun PrintGoatInfo(goat: goat) {\n    println(\"Goat is Happy: ${goat.happy}\") // Should be isHappy\n    println(\"Goat Max Speed: ${goat.maxSpeed}\") // Should be MAX_SPEED\n}\n</code></pre>"},{"location":"lang/kotlin/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Refer to the Foundational Code Standards for general commenting and documentation guidelines.</p>"},{"location":"lang/kotlin/#documentation-example","title":"Documentation Example","text":"<pre><code>/**\n * Represents a goat with a name, age, and a method to determine if the goat is happy.\n * \n * This data class simplifies the process of creating goat objects with essential attributes\n * and provides a method to assess the goat's happiness based on specific conditions.\n *\n * **Usage Example:**\n * `\n * val billy = Goat(\"Billy\", 5)\n * println(billy.isHappy(3)) // Prints true or false depending on the number of meals.\n * `\n * \n * @property name The name of the goat.\n * @property age The age of the goat in years.\n * @constructor Creates a goat object with the specified name and age.\n * @throws IllegalArgumentException if the age is negative.\n * @return A new instance of a Goat.\n*/\ndata class Goat(val name: String, val age: Int) {\n  init {\n    if (age &lt; 0) throw IllegalArgumentException(\"Age cannot be negative\")\n  }\n\n  /**\n   * Determines if the goat is happy based on the number of meals it has received.\n   * \n   * A goat is considered happy if it has been fed at least twice a day.\n   * \n   * @param meals The number of meals the goat has received today.\n   * @return True if the goat is happy (fed at least twice today), false otherwise.\n   * @throws IllegalArgumentException if the number of meals is negative.\n   */\n  fun isHappy(meals: Int): Boolean {\n    if (meals &lt; 0) throw IllegalArgumentException(\"Meals cannot be negative\")\n    return meals &gt;= 2\n  }\n}\n</code></pre>"},{"location":"lang/kotlin/#kdoc","title":"KDoc","text":"<p>Use KDoc for documenting classes, functions, and properties.</p>"},{"location":"lang/kotlin/#dokka","title":"Dokka","text":"<p>Use Dokka, an API documentation generator, for automatic documentation in various formats.</p>"},{"location":"lang/kotlin/#idioms-and-best-practices","title":"Idioms and Best Practices","text":"<p>Kotlin offers a wealth of idiomatic practices and patterns that can make your code more concise, readable, and idiomatic. This section focuses on leveraging Kotlin's unique features effectively.</p>"},{"location":"lang/kotlin/#collections-and-ranges","title":"Collections and Ranges","text":"<p>Use Kotlin's standard library functions for collection manipulation.</p> <pre><code>val adultGoats = goats.filter { it.age &gt;= 2 }.map { it.name }\n</code></pre>"},{"location":"lang/kotlin/#null-safety","title":"Null Safety","text":"<p>Utilize Kotlin's null safety features like <code>?.</code>, <code>?:</code>, and <code>!!</code> operators judiciously.</p> <pre><code>val name: String? = goat.getName()\nprintln(name?.length ?: \"No name\")\n</code></pre>"},{"location":"lang/kotlin/#lazy-initialization","title":"Lazy Initialization","text":"<p>Delegate property initialization to be calculated only when accessed for the first time.</p> <pre><code>class GoatTracker {\n    private val numGoatsFed: Int by lazy {\n        // This code to count goats is executed only on first access\n        countGoatsInPen()\n    }\n\n    private fun countGoatsInPen(): Int {\n        return 10 // Simulate counting goats\n    }\n}\n</code></pre>"},{"location":"lang/kotlin/#data-classes","title":"Data Classes","text":"<p>Use data classes for holding data. They provide <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>copy()</code>, and <code>componentN()</code> functions automatically.</p> <pre><code>data class Goat(val name: String, val age: Int)\n</code></pre>"},{"location":"lang/kotlin/#default-values","title":"Default Values","text":"<p>Assign default values to constructor parameters or function parameters for optional arguments.</p> <pre><code>class Goat(val name: String = \"Billy\", var age: Int = 1) {\n    fun yell(sound: String = \"Meeee!\"): String {\n        return \"$name the goat yells: $sound\"\n    }\n}\n\nval myGoat = Goat() // Uses default name (\"Billy\") and age (1)\nval grumpyGoat = Goat(\"Grumpy\", 5, \"Baaaaaah!\") // Custom name, age, and sound\n</code></pre>"},{"location":"lang/kotlin/#operator-overloading","title":"Operator Overloading","text":"<p>Overload operators for custom classes using functions named after the operator.</p> <pre><code>data class Age(val years: Int) {\n  operator fun plus(yearsToAdd: Int): Age {\n    return Age(years + yearsToAdd)\n  }\n}\n\nval goatAge = Age(2)\nval olderGoatAge = goatAge + 3\n</code></pre>"},{"location":"lang/kotlin/#extension-functions","title":"Extension Functions","text":"<p>Add new functions to existing classes without inheritance.</p> <pre><code>fun String.addGoatEmoji(): String = \"$this \ud83d\udc10\"\n</code></pre>"},{"location":"lang/kotlin/#scope-functions","title":"Scope Functions","text":"<p>Use <code>apply</code>, <code>with</code>, <code>run</code>, <code>also</code>, and <code>let</code> for executing a block of code within the context of an object.</p> <pre><code>val billy = Goat(\"Billy\", 1).apply { age = 2 }\n</code></pre>"},{"location":"lang/kotlin/#string-interpolation","title":"String Interpolation","text":"<p>Embed expressions within strings using ${expression} syntax for dynamic string creation.</p> <pre><code>val goatName = \"Buttercup\"\nval message = \"The goat $goatName is ${if (myGoat.age &gt; 3) \"old\" else \"young\"}.\"\n</code></pre>"},{"location":"lang/kotlin/#instance-checks","title":"Instance Checks","text":"<p>Use <code>is</code> and <code>!is</code> operators for type checks and smart casts. Use <code>as?</code> for safe casts.</p> <pre><code>fun feed(animal: Any) {\n  if (animal is Goat) {\n    val goat = animal as Goat  // Safe cast if it's a Goat\n    println(\"Feeding grass to ${goat.name}\")\n  } else {\n    println(\"This animal doesn't eat grass!\")\n  }\n}\n</code></pre>"},{"location":"lang/kotlin/#tools-and-resources","title":"Tools and Resources","text":"<p>Ensuring a consistent development environment and utilizing static analysis tools are crucial steps for maintaining high code quality in Kotlin projects.</p>"},{"location":"lang/kotlin/#recommended-static-analysis-tools-for-kotlin","title":"Recommended Static Analysis Tools for Kotlin","text":"<p>Static analysis tools help identify potential issues early in the development process. For Kotlin, several tools are particularly effective:</p> <ul> <li>detekt: A static code analysis tool for Kotlin that provides code style   checks, complexity   checks, and more. It is configurable and integrates well with Gradle and Maven.</li> <li>ktlint: An anti-bikeshedding Kotlin linter with   built-in formatter. It enforces a consistent   code style and can automatically format code per the Kotlin coding standards.</li> <li>SonarQube for Kotlin: Extends SonarQube's capabilities to Kotlin, offering code   smells   detection, bugs tracking, and code quality metrics.</li> <li>Android Lint: For Android projects, Android Lint includes specific checks for   Kotlin code,   ensuring best practices for Android development are followed.</li> </ul>"},{"location":"lang/kotlin/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kotlin Coding Conventions: The official coding conventions for Kotlin by   JetBrains.</li> <li>Android Kotlin Style Guide: The official style guide for Android   development in Kotlin.</li> <li>Awesome Kotlin: A curated list of Kotlin resources, libraries, and tools.</li> </ul>"},{"location":"lang/kotlin/#intellij-idea-configuration","title":"IntelliJ IDEA Configuration","text":"<p>To align with the coding standards outlined in this guide, we provide a custom IntelliJ IDEA code style configuration. This configuration ensures that your IDE automatically adheres to the formatting rules and conventions specified herein.</p> EditorConfigXML Config <ol> <li>Download the .editorconfig.</li> <li>Open IntelliJ IDEA.</li> <li>Go to <code>File</code> &gt; <code>Settings</code> (on Windows and Linux) or <code>IntelliJ IDEA</code> &gt; <code>Preferences</code> (on macOS).</li> <li>Navigate to <code>Editor</code> &gt; <code>Code Style</code>.</li> <li>Ensure the checkbox for Enable EditorConfig support is :checked: checked.</li> <li>Rename the downloaded file to <code>.editorconfig</code>.</li> <li>Add the <code>.editorconfig</code> file to your project root directory.</li> </ol> <p>EditorConfig File \u00a0</p> <ol> <li>Download the XML config file.</li> <li>Open IntelliJ IDEA.</li> <li>Go to <code>File</code> &gt; <code>Settings</code> (on Windows and Linux) or <code>IntelliJ IDEA</code> &gt; <code>Preferences</code> (on macOS).</li> <li>Navigate to <code>Editor</code> &gt; <code>Code Style</code>.</li> <li>Click on the gear icon (<code>\u2699\ufe0f</code>) next to the <code>Scheme</code> dropdown at the top of the window and    select <code>Import Scheme</code> &gt; <code>IntelliJ IDEA code style XML</code>.</li> <li>Find and select the downloaded XML file, then click <code>OK</code>.</li> <li>Ensure the newly imported scheme is selected in the <code>Scheme</code> dropdown.</li> <li>Click <code>Apply</code> and <code>OK</code> to save the changes.</li> </ol> <p>IntelliJ XML Config \u00a0</p> <p>By configuring your IDE to adhere to Kotlin's style conventions and integrating static analysis tools into your development process, you can significantly enhance code quality, readability, and maintainability. These tools not only help catch potential bugs early but also ensure your codebase remains clean and consistent with Kotlin best practices.</p>"},{"location":"lang/objective-c/","title":"Objective-C Style Guide","text":"<p>This guide is designed to foster clean, maintainable, and idiomatic Objective-C code. It aligns with the community standards and best practices for Objective-C development.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Objective-C.</p>"},{"location":"lang/objective-c/#formatting","title":"Formatting","text":"<p>The formatting rules for Objective-C adhere to our foundational formatting standards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/objective-c/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Objective-C adhere to our foundational naming conventions:</p> <ul> <li>PascalCase for classes, protocols, and enumeration types</li> <li>camelCase for methods, variables, and properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul>"},{"location":"lang/objective-c/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Well-crafted comments and documentation are essential for maintaining the clarity, understandability, and usability of Objective-C code. This section focuses on best practices for effective commenting and leveraging Objective-C and Xcode features to create comprehensive documentation.</p>"},{"location":"lang/objective-c/#inline-comments","title":"Inline Comments","text":"<ul> <li> <p>Clarify Complex Logic: Use inline comments to explain complex algorithms, decisions that are   not immediately obvious, or to provide context that is not readily apparent from the code itself.</p> Example of Inline Comment for Complex Logic (goat headbutt damage calculation)<pre><code>// Apply bonus damage based on goat's horn strength\nint headbuttDamage = baseDamage + (_goat.hornStrength * kHeadbuttStrengthMultiplier);\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#documentation-comments","title":"Documentation Comments","text":"<ul> <li> <p>Use Xcode's Markup for Documentation: Employ documentation comments above methods, properties,   and classes to describe their purpose and usage. Xcode's markup syntax allows you to format these   comments and include them in the Quick Help.</p> <pre><code>/**\n Feeds a particular goat with the specified food.\n\n @param goat The goat to be fed.\n @param food The type of food to feed the goat.\n @return A boolean indicating if the feeding was successful.\n*/\n- (BOOL)feedGoat:(GTFGoat *)goat withFood:(NSString *)food;\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#header-documentation","title":"Header Documentation","text":"<ul> <li> <p>Public Interfaces: Document the public interfaces of your classes in the header files. This   makes it easier for other developers to understand how to use your classes without needing to dive   into the implementation details.</p> <pre><code>// GTFGoatFeeder.h\n/**\n A class responsible for feeding goats.\n\n This class provides methods to feed goats efficiently and track their feeding status.\n*/\n@interface GTFGoatFeeder : NSObject\n\n/**\n Feeds all hungry goats in the pen.\n\n @discussion This method iterates over all goats in the pen and feeds those that are hungry.\n @param pen The pen containing the goats to be fed.\n*/\n- (void)feedHungryGoatsInPen:(GTFGoatPen *)pen;\n\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#todo-and-fixme-comments","title":"TODO and FIXME Comments","text":"<ul> <li> <p>Highlight Areas Needing Work: Use <code>TODO:</code> and <code>FIXME:</code> comments to mark areas of the code that   need improvement or completion. Include your initials and the current date for traceability.</p> <pre><code>// TODO: [TICKET-1234] Optimize goat feeding algorithm for larger pens\n// FIXME: [GOAT-420] Resolve crash when goat name is nil\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#deprecation-notices","title":"Deprecation Notices","text":"<ul> <li> <p>Mark Deprecated Methods: Use the <code>NS_DEPRECATED</code> macro to mark methods that are deprecated.   Include a message directing developers to the preferred alternative.</p> <pre><code>- (void)oldFeedMethod NS_DEPRECATED(10_0, 10_4, 2_0, 2_0, \"Use -feedGoat:withFood: instead\");\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#avoid-commented-out-code","title":"Avoid Commented-Out Code","text":"<ul> <li>Remove Unused Code: Instead of leaving commented-out code blocks in your codebase, rely on   version control to keep a history of changes. Commented-out code can clutter your codebase and   lead to confusion.</li> </ul>"},{"location":"lang/objective-c/#best-practices-and-idioms","title":"Best Practices and Idioms","text":""},{"location":"lang/objective-c/#memory-management","title":"Memory Management","text":"<ul> <li> <p>Understand and Apply ARC Correctly: Automatic Reference Counting (ARC) manages the memory of   your Objective-C objects. Ensure you understand ARC's rules around ownership and references to   prevent memory leaks and retain cycles.</p> Example of ARC Management (using strong and weak references)<pre><code>// Goat owner strongly references the goat, while the hay is weakly referenced to avoid retain cycles\nGoat* strongGoat = [[Goat alloc] init];\n__weak Hay* weakHay = [self findNearestHay];\n[strongGoat eatHay:weakHay];  // Goat eats the hay without creating a retain cycle\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#use-of-literals","title":"Use of Literals","text":"<ul> <li> <p>Prefer Objective-C Literals: Use Objective-C literals   for <code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, and <code>NSNumber</code> to make your code more concise and   readable.</p> Example of Using Literals (cleaner and more readable approach)<pre><code>NSString* goatNickname = @\"Headbutt McGee\";\nNSDictionary* powerUpDetails = @{@\"name\": @\"Jetpack\", @\"duration\": @10};\nNSArray* availableHays = @[@\"Oat Hay\", @\"Clover Hay\"];\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#nullability-annotations","title":"Nullability Annotations","text":"<ul> <li> <p>Specify Nullability in Headers: Use nullability   annotations (<code>NS_ASSUME_NONNULL_BEGIN</code>, <code>NS_ASSUME_NONNULL_END</code>, <code>nullable</code>, <code>nonnull</code>) in your   headers to provide more information to the compiler, improving code safety and reducing the   possibility of null pointer exceptions.</p> Example of Nullability Annotations (specifying nonnull for goat parameter)<pre><code>@interface GoatManager\n- (void) feedHayToGoat:(nonnull Goat*)goat;\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#block-usage","title":"Block Usage","text":"<ul> <li> <p>Avoid Retain Cycles with Blocks: When capturing <code>self</code> in a block, especially in asynchronous   calls, use a weak reference to avoid retain cycles.</p> Example of Block with Weak Reference (avoiding retain cycles)<pre><code>__weak Goat* weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n  // Perform asynchronous task\n  if (weakSelf) {\n    [weakSelf goatJumpedSuccessfully];  // Use weakSelf to avoid retain cycle\n  }\n});\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#error-handling","title":"Error Handling","text":"<ul> <li> <p>Use NSError for Error Reporting: When designing methods that can fail, use an <code>NSError</code>   pointer to pass back error information to the caller.</p> Example of Error Handling with NSError (checking for error during hay consumption)<pre><code>NSError* error = nil;\nBOOL hayConsumed = [goat eatHay:hay error:&amp;error];\nif (!hayConsumed &amp;&amp; error) {\n  NSLog(@\"Error eating hay: %@\", error.localizedDescription);\n}\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#testing","title":"Testing","text":"<ul> <li> <p>Write Unit Tests: Leverage XCTest framework to write unit tests for your Objective-C classes.   Testing contributes significantly to the robustness and maintainability of your code.</p> Example of Unit Test (testing goat movement using XCTest)<pre><code>- (void) testGoatMovement {\n  Goat* goat = [[Goat alloc] init];\n  goat.position = CGPointMake(100, 100);\n  [goat moveForward];\n  XCTAssertTrue(goat.position.x &gt; 100, @\"Goat should move forward\");\n}\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#delegate-patterns","title":"Delegate Patterns","text":"<ul> <li> <p>Use Delegates for Callbacks and Event Handling: The delegate pattern is widely used in Cocoa   and Cocoa Touch for callbacks and handling events. Define protocols for your delegates to ensure   they implement the necessary methods.</p> Example of Delegate Pattern (Goat informs Farmer about completion of task)<pre><code>@protocol GoatTaskCompletionDelegate\n\n- (void) goat:(Goat *)goat didCompleteTask:(NSString *)task;\n\n@end\n\n@interface Goat ()\n\n@property (nonatomic, weak) id&lt;GoatTaskCompletionDelegate&gt; delegate;\n\n@end\n\n- (void) performTask {\n  // Simulate some work performed by the goat\n  sleep(2);\n  [self.delegate goat:self didCompleteTask:@\"Hay delivery\"];\n}\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#categories-for-class-extensions","title":"Categories for Class Extensions","text":"<ul> <li> <p>Extend Classes with Categories: Use categories to add methods to existing classes, including   framework classes, without subclassing them. This is particularly useful for adding utility   methods.</p> Example of Category (Adding a method to calculate goat age in years)<pre><code>@interface Goat (GoatAge)\n\n- (int) calculateAgeInYears;\n\n@end\n\n@implementation Goat (GoatAge)\n\n- (int) calculateAgeInYears {\n  // Calculate age based on goat's birthdate\n  NSCalendar *calendar = [NSCalendar currentCalendar];\n  NSDateComponents *ageComponents = [calendar components:NSCalendarUnitYear fromDate:self.dateOfBirth toDate:[NSDate date] options:0];\n  return (int)ageComponents.year;\n}\n\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#use-of-instancetype","title":"Use of <code>instancetype</code>","text":"<ul> <li> <p>Prefer <code>instancetype</code> for Type-Specific Initializers: When defining initializers,   return <code>instancetype</code> instead of <code>id</code> to ensure type safety and clarity.</p> Example of Initializer with instancetype<pre><code>@interface Goat alloc initWithName:(NSString *)name birthDate:(NSDate *)birthDate;\n\n@end\n\n@implementation Goat\n\n- (instancetype)initWithName:(NSString *)name birthDate:(NSDate *)birthDate {\n  self = [super init];\n  if (self) {\n    _name = name;\n    _dateOfBirth = birthDate;\n  }\n  return self;\n}\n\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#collections-and-fast-enumeration","title":"Collections and Fast Enumeration","text":"<ul> <li> <p>Leverage Fast Enumeration and Collection Literals: Use fast enumeration (<code>for...in</code> loops) for   iterating over collections. Prefer collection literals for concise and readable collection   initialization.</p> Example of Fast Enumeration and Collection Literals (feeding all goats hay)<pre><code>NSArray&lt;Hay*&gt; *availableHay = ...; // Array of available hay objects\n\nfor (Hay *hay in availableHay) {\n  [[GoatManager sharedInstance] feedHay:hay toGoats:self.goats];\n}\n\n// ...\n\n@interface GoatManager\n\n+ (instancetype)sharedInstance;\n\n- (void) feedHay:(Hay *)hay toGoats:(NSArray&lt;Goat*&gt; *)goats;\n\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#properties-and-dot-syntax","title":"Properties and Dot Syntax","text":"<ul> <li> <p>Use Properties and Dot Syntax for Encapsulation: Define properties for encapsulating data and   accessing instance variables. Use dot syntax for property access, which is more concise and   readable.</p> Example of Properties and Dot Syntax (accessing goat's name)<pre><code>@interface Goat\n\n@property (nonatomic, strong) NSString *name;\n\n@end\n\n@implementation Goat\n\n// ...\n\n- (void) introduceMyself {\n  NSLog(@\"I am a goat, and my name is %@\", self.name);\n}\n\n@end\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#nil-checking","title":"Nil Checking","text":"<ul> <li> <p>Messages to <code>nil</code> Are No-ops: Objective-C allows messages to be sent to <code>nil</code>, which   simplifies nil checking in many cases. However, be mindful of cases where this behavior may lead   to unexpected results, especially with methods expected to return non-nil values.</p> Example of Nil Checking (checking for delegate before sending message)<pre><code>if (self.delegate) {\n  [self.delegate goat:self didCompleteTask:@\"Fence repaired\"];\n} else {\n  NSLog(@\"No delegate assigned to receive task completion notification\");\n}\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#avoiding-primitive-obsession","title":"Avoiding Primitive Obsession","text":"<ul> <li> <p>Use Strongly Typed Objects Over Primitives: Instead of relying on primitives (   e.g., <code>int</code>, <code>NSString *</code> for IDs), use more descriptive types or classes that can provide   additional context and validation.</p> Example of Primitive Obsession (using int for goat ID)<pre><code>int goatID = 123;\n\n// More descriptive approach (using GoatID class)\n@interface GoatID : NSObject\n\n@property (nonatomic, strong) NSString* identifier;\n\n@end\n\n@implementation GoatID\n\n- (instancetype)initWithID:(NSString *)identifier {\n  self = [super init];\n  if (self) {\n    _identifier = identifier;\n  }\n  return self;\n}\n\n@end\n\nGoatID* strongGoatID = [[GoatID alloc] initWithID:@\"GOAT123\"];\n\n// Accessing the ID\nNSLog(@\"Primitive Goat ID: %d\", goatID);\nNSLog(@\"GoatID object identifier: %@\", strongGoatID.identifier);\n</code></pre> </li> </ul>"},{"location":"lang/objective-c/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/objective-c/#xcode","title":"Xcode","text":"<ul> <li>Primary IDE for Objective-C: Xcode, developed by Apple, is the most comprehensive and powerful   IDE for Objective-C development, offering advanced code editing, debugging, and UI design   capabilities.</li> <li>Code Formatting: Utilize Xcode's built-in code formatting features to maintain consistency.   Customize formatting options in Xcode preferences to align with your project's style guide.</li> <li>Refactoring Tools: Leverage Xcode's refactoring tools to safely rename symbols, extract   methods, and more, ensuring your code remains clean and maintainable.</li> <li>Static Analysis: Regularly use Xcode's built-in static analysis tool to detect potential   memory leaks, logical errors, and other issues early in the development cycle.</li> </ul>"},{"location":"lang/objective-c/#dependency-management","title":"Dependency Management","text":"<ul> <li>CocoaPods for Managing Libraries: Use CocoaPods, an Objective-C dependency manager, to   integrate third-party libraries into your projects easily.</li> <li>Define your project's dependencies in a <code>Podfile</code>, and use CocoaPods to manage library versions   and updates seamlessly.</li> </ul>"},{"location":"lang/objective-c/#additional-resources","title":"Additional Resources","text":"<ul> <li>Objective-C Programming Language Guide: Offers an in-depth look at Objective-C's   syntax, features, and best practices.</li> <li>Apple's Objective-C Coding Guidelines: Provides Apple's recommendations   for writing Objective-C code.</li> </ul>"},{"location":"lang/python/","title":"Python Style Guide","text":"<p>This guide is dedicated to writing clean, Pythonic code that adheres to best practices and embraces the nuances of Python development. It underscores idiomatic usage, performance, and maintainability.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Python.</p>"},{"location":"lang/python/#formatting","title":"Formatting","text":"<p>While Python's PEP 8 provides comprehensive formatting guidelines, our foundational  formatting standards also apply. Key Python-specific considerations include:</p> <ul> <li>Indentation: Use 4 spaces per indentation level.</li> <li>Line Length: Limit lines to 79 characters (and docstrings/comments to 72).</li> <li>Imports: Group imports into standard library, third-party, and local application/library   specific, separated by blank lines.</li> <li>Whitespace: Use whitespace sparingly inside parentheses, brackets, and braces.</li> </ul>"},{"location":"lang/python/#naming-conventions","title":"Naming Conventions","text":"<p>Pythonic naming favors readability and conciseness:</p> <ul> <li>Classes: Use <code>CamelCase</code> for class names without underscores.</li> <li>Functions and Variables: Use <code>snake_case</code> for function names, variables, and method names.</li> <li>Constants: Define constants in <code>UPPER_SNAKE_CASE</code>.</li> <li>Protected and Private: Use <code>_protected</code> and <code>__private</code> naming conventions for non-public   methods and variables.</li> </ul>"},{"location":"lang/python/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/python/#inline-comments","title":"Inline Comments","text":"<p>Inline comments should be used sparingly and must be meaningful. Explain \"why\" rather than \"what\".</p>"},{"location":"lang/python/#docstrings","title":"Docstrings","text":"<p>Follow PEP 257 for docstring conventions. Use triple double quotes and describe the function's effect as a command:</p> <pre><code>def feed_goat(goat, food):\n    \"\"\"\n    Feed a goat with the specified food.\n\n    Args:\n        goat (Goat): The goat to be fed.\n        food (str): The type of food.\n\n    Returns:\n        bool: True if feeding is successful, False otherwise.\n    \"\"\"\n</code></pre> <p>Error Handling Prefer explicit exception handling over silent failures. Catch specific exceptions whenever possible:</p> <pre><code>try:\n    # risky operation\nexcept ValueError as e:\n    # specific error handling\nexcept Exception as e:\n    # generic error handling\n</code></pre>"},{"location":"lang/python/#idioms-and-best-practices","title":"Idioms and Best Practices","text":""},{"location":"lang/python/#list-comprehensions","title":"List Comprehensions","text":"<p>Use list comprehensions to create lists in a concise and readable manner:</p> <pre><code>squared = [x**2 for x in range(10)]\n</code></pre>"},{"location":"lang/python/#the-zen-of-python","title":"The Zen of Python","text":"<p>Embrace the Zen of Python (import this) as a guiding philosophy. Prioritize readability, simplicity, and the \"Pythonic\" way of accomplishing tasks.</p>"},{"location":"lang/python/#generators","title":"Generators","text":"<p>Leverage generators to create iterators without storing the entire sequence in memory:</p> <pre><code>def goat_names():\n    for goat in goat_herd:\n        yield goat.name\n</code></pre>"},{"location":"lang/python/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/python/#algorithms-and-design-patterns","title":"Algorithms and Design Patterns","text":"<ul> <li>Algorithms<ul> <li>algorithms - Minimal examples of data structures and algorithms.</li> <li>python-ds - A collection of data structure and algorithms for coding interviews.</li> <li>sortedcontainers - Fast and pure-Python implementation of sorted collections.</li> <li>thealgorithms - All Algorithms implemented in Python.</li> </ul> </li> <li>Design Patterns<ul> <li>pypattyrn - A simple yet effective library for implementing common design patterns.</li> <li>python-patterns - A collection of design patterns in Python.</li> <li>transitions - A lightweight, object-oriented finite state machine implementation.</li> </ul> </li> </ul>"},{"location":"lang/python/#ides-and-editor-plugins","title":"IDEs and Editor Plugins","text":"<ul> <li>PyCharm - Commercial Python IDE by JetBrains.</li> <li>Visual Studio with PTVS</li> <li>Visual Studio Code with Python</li> <li>spyder - Open Source Python IDE.</li> </ul>"},{"location":"lang/python/#static-analysis","title":"Static Analysis","text":"<ul> <li>Black: The uncompromising Python code formatter that adheres to PEP 8 and improves code readability.</li> <li>Flake8: A tool that enforces PEP 8 style guide and helps catch common programming errors.</li> <li>MyPy: A static type checker for Python that supports gradual typing.</li> <li>Pytest: Utilize pytest for testing and coverage analysis.</li> <li>Sphinx - Python Documentation generator.: Use Sphinx for generating documentation from docstrings.</li> <li>Pylint: A source code analyzer that checks for errors in Python code.</li> </ul>"},{"location":"lang/rust/","title":"Rust Style Guide","text":"<p>This guide focuses on best practices and stylistic conventions for writing Rust code, aiming for code that is not only efficient and safe but also clean, readable, and consistent.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Rust.</p>"},{"location":"lang/rust/#formatting","title":"Formatting","text":"<p>The formatting rules for Rust adhere to our Foundational Formatting Standards with the following exceptions:</p> <ul> <li>Indentation: Use 4 spaces per indentation level.</li> </ul> <p>Otherwise, follow the conventions outlined in the foundational standards, summarized below:</p> <ul> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/rust/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>UpperCamelCase (PascalCase) for types (classes, structs, enums), and enum variants.</li> <li>snake_case for function and method names, local variables, struct fields, macro names, and   properties.</li> <li>SCREAMING_SNAKE_CASE for constants (consts and immutable statics).</li> <li>lowercase for package names, using concatenated words (avoid underscores).</li> <li>Use a raw identifier (<code>r#</code>) or trailing underscore for names that are reserved words.</li> </ul> <p>Additional Tips:</p> <ul> <li>Favor clarity over brevity: Choose names that clearly convey the purpose of the item.</li> <li>Avoid abbreviations or acronyms unless they are widely understood (e.g., <code>HTTP</code>, <code>XML</code>).</li> <li>Maintain consistency throughout the codebase for a uniform style.</li> </ul>"},{"location":"lang/rust/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/rust/#purpose-and-clarity","title":"Purpose and Clarity","text":"<ul> <li>Clearly explain the purpose and functionality of code sections using comments.</li> <li>Avoid redundant comments that simply restate the code itself.</li> <li> <p>Use comments to clarify non-obvious logic, complex algorithms, or design choices.</p> Example<pre><code>// This function calculates the average weight (in kilograms) of a herd of goats. \n// It takes a vector of goat weights as input and returns the average weight as a float.\n\nfn average_goat_weight(weights: &amp;[f32]) -&gt; f32 {\n    // Ensure there are goats in the herd (avoid division by zero)\n    if weights.is_empty() {\n        panic!(\"Cannot calculate average weight for an empty herd!\");\n    }\n\n    // Calculate the sum of all goat weights\n    let total_weight = weights.iter().sum::&lt;f32&gt;();\n\n    // Calculate the average weight by dividing the total weight by the number of goats\n    total_weight / weights.len() as f32\n}\n\n// Example usage: Find the average weight of a herd with recorded weights\nfn main() {\n    let goat_weights = vec![35.2, 42.1, 28.7, 48.9]; // Example weights in kilograms\n\n    let average_weight = average_goat_weight(&amp;goat_weights);\n    println!(\"The average weight of the goats in the herd is {:.2} kg\", average_weight);\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#documentation-for-public-items","title":"Documentation for Public Items","text":"<ul> <li>Use doc comments for public items (functions, structs, enums) to provide a detailed description,   usage examples, and relevant information for future developers using the code.</li> <li> <p>Doc comments utilize a specific syntax starting with <code>///</code>.</p> Example<pre><code>/// This structure represents a single goat in a herd.\n///\n/// It stores information about a goat, including its name, age, and weight.\n/// This information can be used for various purposes, such as managing a farm,\n/// tracking goat growth, or simply keeping track of your favorite goats.\n///\n#[derive(Debug)]  // Include Debug trait for easy printing\npub struct Goat {\n    /// The name of the goat.\n    pub name: String,\n\n    /// The age of the goat in years.\n    pub age: u32,\n\n    /// The weight of the goat in kilograms.\n    pub weight: f32,\n}\n\n/// This function calculates the average weight (in kilograms) of a herd of goats.\n///\n/// It takes a slice of `Goat` structs as input and returns the average weight as a float.\n/// This function can be helpful for monitoring the overall health and well-being of a goat herd.\n///\n/// # Errors\n///\n/// This function panics if there are no goats in the herd (to avoid division by zero).\n/// Consider using a `Result` type for more granular error handling in the future.\n///\n/// # Examples\n///\n/// ```rust\n/// let herd = vec![\n///     Goat { name: String::from(\"Billy\"), age: 2, weight: 35.2 },\n///     Goat { name: String::from(\"Beatrice\"), age: 1, weight: 42.1 },\n///     Goat { name: String::from(\"George\"), age: 4, weight: 48.9 },\n/// ];\n///\n/// let average_weight = average_goat_weight(&amp;herd);\n/// println!(\"The average weight of the goats in the herd is {:.2} kg\", average_weight);\n/// ```\n///\npub fn average_goat_weight(goats: &amp;[Goat]) -&gt; f32 {\n    // Ensure there are goats in the herd (avoid division by zero)\n    if goats.is_empty() {\n        panic!(\"Cannot calculate average weight for an empty herd!\");\n    }\n\n    // Calculate the sum of all goat weights\n    let total_weight = goats.iter().map(|goat| goat.weight).sum::&lt;f32&gt;();\n\n    // Calculate the average weight by dividing the total weight by the number of goats\n    total_weight / goats.len() as f32\n}\n\n/// Example usage: Find the average weight of a herd with recorded information for each goat\nfn main() {\n    let herd = vec![\n        Goat { name: String::from(\"Billy\"), age: 2, weight: 35.2 },\n        Goat { name: String::from(\"Beatrice\"), age: 1, weight: 42.1 },\n        Goat { name: String::from(\"George\"), age: 4, weight: 48.9 },\n    ]; // Example herd of goats\n\n    let average_weight = average_goat_weight(&amp;herd);\n    println!(\"The average weight of the goats in the herd is {:.2} kg\", average_weight);\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#level-of-detail","title":"Level of Detail","text":"<ul> <li>Tailor the level of detail in comments to the complexity of the code.</li> <li> <p>Simpler code sections might require fewer comments, while intricate logic could benefit from more   explanation.</p> Simple FunctionComplex Function <pre><code>fn set_name(&amp;mut self, new_name: &amp;str) {\n    self.name = String::from(new_name);\n}\n</code></pre> <pre><code>fn calculate_ideal_diet(&amp;self) -&gt; Vec&lt;FoodType&gt; {\n    // ... (complex logic considering factors like age, breed, and activity level)\n}\n// Detailed doc comment explaining the logic and considerations.\n</code></pre> </li> </ul>"},{"location":"lang/rust/#consistency","title":"Consistency","text":"<ul> <li>Maintain consistent formatting and style for comments throughout the codebase.</li> <li>Consider using tools or linters to enforce comment style guidelines.</li> </ul>"},{"location":"lang/rust/#best-practices-and-idioms","title":"Best Practices and Idioms","text":""},{"location":"lang/rust/#ownership-and-borrowing","title":"Ownership and Borrowing","text":"<ul> <li> <p>Understand and leverage Rust's ownership and borrowing system, a core concept that ensures memory   safety and prevents common memory-related errors.</p> Example<pre><code>fn feed_goat(goat: &amp;mut CheerfulChewer, food: FoodType) {\n    // Goat is borrowed mutably (`&amp;mut`) to modify its happiness level\n    goat.happiness += 10; // Update happiness through the borrowed reference\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#pattern-matching","title":"Pattern Matching","text":"<ul> <li> <p>Utilize pattern matching (<code>match</code> expressions) for handling different variants of enums, iterating   over collections, and destructuring complex data structures.</p> Example<pre><code>fn express_emotion(goat: &amp;CheerfulChewer) {\n    match goat.calculate_happiness() {\n        Emotion::Happy =&gt; println!(\"{} the goat is feeling happy!\", goat.name),\n        Emotion::Sad =&gt; println!(\"{} the goat looks a bit sad.\", goat.name),\n        // ... (handle other variants)\n    }\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#iterators-and-functional-programming","title":"Iterators and Functional Programming","text":"<ul> <li> <p>Leverage Rust's powerful iterators and functional programming features for concise and expressive   code, especially when dealing with collections like lists or vectors.</p> Example<pre><code>fn suggest_favorite_foods(goat: &amp;CheerfulChewer) -&gt; Vec&lt;FoodType&gt; {\n    let all_foods = [FoodType::HaystackDelight, FoodType::OatmealSurprise, FoodType::CloverCrunch];\n    all_foods.iter()\n        .filter(|food| *food == goat.find_favorite_food().unwrap()) // Filter based on favorite food\n        .cloned() // Clone the matched food type\n        .collect() // Collect results into a vector\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#error-handling-with-result","title":"Error Handling with <code>Result</code>","text":"<ul> <li> <p>Employ the <code>Result</code> type (<code>std::error::Result</code>) for robust error handling. It represents an   operation that can either succeed with a value or fail with an error.</p> Example<pre><code>fn find_favorite_food(goat_name: &amp;str) -&gt; Result&lt;FoodType, String&gt; {\n    // ... (logic to find the goat's favorite food)\n    if goat_name == \"Buttercup\" {\n        Ok(FoodType::OatmealSurprise)\n    } else {\n        Err(format!(\"Favorite food for {} unknown!\", goat_name))\n    }\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#propagating-and-handling-errors","title":"Propagating and Handling Errors","text":"<ul> <li> <p>Propagate errors up the call stack when an error occurs within a function. This allows for   handling the error at an appropriate level in your program.</p> Example<pre><code>fn feed_goat(goat_name: &amp;str, food: FoodType) -&gt; Result&lt;(), String&gt; {\n    let favorite_food = find_favorite_food(goat_name)?; // Propagate error from find_favorite_food\n    if favorite_food != food {\n        Err(format!(\"{} the goat only eats {}\", goat_name, favorite_food))\n    } else {\n        Ok(())\n    }\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#option-type","title":"Option Type","text":"<ul> <li> <p>Utilize the <code>Option</code> type to represent the possibility of a value being absent. This is   particularly useful for handling potential errors or missing data gracefully.</p> Example<pre><code>fn get_favorite_food(goat_name: &amp;str) -&gt; Option&lt;FoodType&gt; {\n    // ... (logic to find the goat's favorite food)\n    Some(FoodType::OatmealSurprise)  // Return Some(value) if found\n    // or None if not found\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#iterators-and-functional-programming-concepts","title":"Iterators and Functional Programming Concepts","text":"<ul> <li> <p>Leverage Rust's powerful iterators and functional programming techniques like <code>map</code>, <code>filter</code>,   and <code>fold</code> to manipulate collections and data structures concisely.</p> Example<pre><code>let all_foods = [FoodType::HaystackDelight, FoodType::OatmealSurprise, FoodType::CloverCrunch];\nlet favorite_food = FoodType::OatmealSurprise;\nlet favorite_food_index = all_foods.iter().position(|food| *food == favorite_food);\n\nmatch favorite_food_index {\n    Some(index) =&gt; println!(\"Favorite food found at index {}\", index),\n    None =&gt; println!(\"Favorite food not found in the list\"),\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#generics","title":"Generics","text":"<ul> <li> <p>Employ generics to write code that works with various data types, promoting code reusability and   flexibility in your goat management program.</p> Example<pre><code>fn feed_goat&lt;T: Food&gt;(goat: &amp;mut CheerfulChewer, food: T) {\n    // ... (logic to feed the goat, potentially adjusting happiness based on food type T)\n}\n</code></pre> </li> </ul>"},{"location":"lang/rust/#smart-pointers","title":"Smart Pointers","text":"<ul> <li> <p>Understand and utilize smart pointers like <code>Rc</code> (reference counting) or <code>Arc</code> (atomic reference   counting) for managing memory ownership scenarios where multiple references to the same data are   needed. Consider these for complex data structures within your goat herd.</p> Example<pre><code>use std::rc::Rc;\n\nstruct Herd {\n    goats: Vec&lt;Rc&lt;CheerfulChewer&gt;&gt;, // Shared ownership of goat data\n}\n\n// ... (functions operating on the Herd with shared goat references)\n</code></pre> </li> </ul>"},{"location":"lang/rust/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/rust/#ides","title":"IDEs","text":"<ul> <li>RustRover | JetBrains IDE</li> <li>Visual Studio Code<ul> <li>Prettier - Code formatter (Rust) \u2014 Opinionated Rust code formatter that autofixes bad syntax (Prettier community plugin)</li> <li>rust-analyzer \u2014 An alternative rust language server to the RLS</li> </ul> </li> </ul>"},{"location":"lang/rust/#formatters","title":"Formatters","text":"<ul> <li>rustfmt \u2014 Rust code formatter maintained by the Rust team and included in cargo</li> <li>dprint \u2014 A pluggable and configurable code formatting platform</li> <li>Prettier Rust \u2014 An opinionated Rust code formatter that autofixes bad syntax (Prettier community plugin)</li> </ul>"},{"location":"lang/rust/#development-tools","title":"Development Tools","text":"<ul> <li>bacon \u2014 background rust code checker, similar to cargo-watch</li> <li>clippy \u2014 Rust lints</li> <li>geiger \u2014 A program that list statistics related to usage of unsafe code in a crate and all its dependencies</li> <li>hot-lib-reloader \u2014 Hot reload Rust code</li> <li>Racer \u2014 code completion for Rust</li> <li>Rustup \u2014 the Rust toolchain installer</li> </ul>"},{"location":"lang/rust/#additional-resources","title":"Additional Resources","text":"<ul> <li>The Rust Programming Language: The official book, an excellent resource for learning   Rust.</li> <li>Rust API Guidelines: A set of Rust API design considerations.</li> <li>Rust Style Guide: Official Rust style guide for code formatting and   conventions.</li> <li>Rust by Example: A collection of runnable examples that illustrate various Rust   concepts and standard libraries.</li> </ul>"},{"location":"lang/shell/","title":"Shell Style Guide","text":"<p>This guide provides recommendations for writing clean, maintainable, and robust shell scripts. It focuses on best practices and idiomatic usage that enhance the readability and functionality of scripts written in Bash or other shell languages.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Shell.</p>"},{"location":"lang/shell/#formatting","title":"Formatting","text":"<p>Follow the Foundational Formatting Standards with these shell-specific guidelines:</p> <ul> <li>Indentation: Use 2 spaces for indentation.</li> <li>Line Length: Aim for 80 characters, with a hard limit of 100 characters per line.</li> <li>Use of Whitespace: Use whitespace to separate commands from their arguments.</li> <li>Quoting Variables: Always quote variables to avoid issues with spaces and globbing: <code>\"$var\"</code>.</li> </ul> <p>Remember, readability and portability are paramount.</p> Example Formatted Shell Script <pre><code>#!/bin/bash\n\n# Function demonstrating various style rules\nperform_operations() {\n  local x=$1\n  local y=$2\n  local sum=$((x + y)) # Space around operators\n\n  echo \"Sum: $sum\"\n\n  # Ternary-like operation using if-else\n  if [[ $sum -gt 10 ]]; then\n    message=\"Greater than 10\"\n  else\n    message=\"Not greater than 10\"\n  fi\n  echo \"$message\"\n\n  # If-else with spacing\n  if [[ $((sum % 2)) -eq 0 ]]; then\n    echo \"Sum is even\"\n  else\n    echo \"Sum is odd\"\n  fi\n\n  # For loop demonstrating continuation indent\n  for i in {0..4}; do\n    echo -n \"$i \" # Demonstrate space in concatenation\n  done\n  echo # New line after loop\n\n  # Try-catch-finally block emulation using trap\n  {\n    throw_error_demo\n  } || {\n    echo \"Caught an error.\"\n  }\n}\n\n# Emulate throwing an error\nthrow_error_demo() {\n  return 1 # Simulate an error\n}\n\n# Main execution\nif [[ $# -eq 2 ]]; then\n  perform_operations \"$1\" \"$2\"\nelse\n  echo \"Usage: $0 &lt;num1&gt; &lt;num2&gt;\"\n  exit 1\nfi\n</code></pre>"},{"location":"lang/shell/#naming-conventions","title":"Naming Conventions","text":"<p>Consistent naming conventions improve script readability and maintainability:</p> <ul> <li>Functions: Lowercase, with underscores to separate words. Define with parentheses and space   before the brace: <code>my_function() { ... }</code>.</li> <li>Variables: Lowercase for local variables, UPPERCASE for exported or global variables.</li> <li>Constants: UPPERCASE with underscores separating words.</li> </ul>"},{"location":"lang/shell/#commenting-and-documentation","title":"Commenting and Documentation","text":""},{"location":"lang/shell/#inline-comments","title":"Inline Comments","text":"<p>Use inline comments sparingly to explain \"why\" rather than \"what\".</p>"},{"location":"lang/shell/#script-header","title":"Script Header","text":"<p>Start each script with a header indicating its purpose, usage, and any dependencies:</p> <pre><code>#!/bin/bash\n# Purpose: Automate goat feeding schedule\n# Usage: ./feed_goats.sh [options]\n# Dependencies: curl, jq\n</code></pre>"},{"location":"lang/shell/#function-comments","title":"Function Comments","text":"<p>Document functions with a description, arguments, and return value:</p> <pre><code># Feeds a specified number of goats.\n# Globals:\n#   FEED_BIN\n# Arguments:\n#   Number of goats\n# Returns:\n#   None\nfeed_goats() {\n  local num_goats=\"$1\"\n  # implementation...\n}\n</code></pre>"},{"location":"lang/shell/#idioms-and-best-practices","title":"Idioms and Best Practices","text":""},{"location":"lang/shell/#conditional-constructs","title":"Conditional Constructs","text":"<ul> <li>Use <code>[[</code> for Conditionals: Prefer the <code>[[</code> keyword for conditional constructs instead of <code>[</code>   for improved readability and additional functionality such as pattern matching and logical   operators.</li> </ul> <pre><code>if [[ $goat_count -gt 10 ]]; then\n    echo \"Herd is too large!\"\nfi\n</code></pre>"},{"location":"lang/shell/#looping-constructs","title":"Looping Constructs","text":"<ul> <li>Use <code>for</code> Loops for Iteration: Utilize <code>for</code> loops for iterating over lists of items, files,   or directory contents. Avoid parsing <code>ls</code> output and prefer globbing or <code>find</code> commands for   listing files.</li> </ul> <pre><code>for goat in \"${goats[@]}\"; do\n    echo \"Processing $goat...\"\ndone\n</code></pre>"},{"location":"lang/shell/#error-handling","title":"Error Handling","text":"<ul> <li>Check Command Return Codes: Always check the return codes of commands and utilities to handle   errors gracefully and prevent silent failures. Use <code>||</code> to execute fallback actions upon command   failure.</li> </ul> <pre><code>rm \"$file\" || echo \"Failed to delete $file\"\n</code></pre>"},{"location":"lang/shell/#function-definitions","title":"Function Definitions","text":"<ul> <li>Declare Functions with <code>function</code>: When defining functions, use the <code>function</code> keyword for   improved clarity and portability across different shell environments.</li> </ul> <pre><code>function feed_goat() {\n    local goat_name=$1\n    local food_amount=$2\n    echo \"Feeding ${goat_name} ${food_amount}kg of food.\"\n}\n</code></pre>"},{"location":"lang/shell/#process-substitution","title":"Process Substitution","text":"<ul> <li>Use Process Substitution: Leverage process substitution <code>&lt;(command)</code> and <code>&gt;(command)</code> to pass   the output of commands as input streams or arguments to other commands. This is especially useful   for complex command pipelines.</li> </ul> <pre><code>diff &lt;(sort file1) &lt;(sort file2)\n</code></pre>"},{"location":"lang/shell/#command-substitution","title":"Command Substitution","text":"<ul> <li>Use Command Substitution: Utilize command substitution <code>$(command)</code> to capture the output of   commands and use them as arguments or assignments within scripts. Avoid using backticks for   command substitution due to readability concerns.</li> </ul> <pre><code>file_size=$(wc -c &lt; \"$file\")\n</code></pre>"},{"location":"lang/shell/#case-statements","title":"Case Statements","text":"<ul> <li>Prefer <code>case</code> Statements: Use <code>case</code> statements for multi-way branching based on patterns or   values. This provides a more readable and structured alternative to nested <code>if</code> statements.</li> </ul> <pre><code>case $option in\n  1)\n    echo \"Option 1 selected.\"\n    ;;\n  2)\n    echo \"Option 2 selected.\"\n    ;;\n  *)\n    echo \"Invalid option.\"\n    ;;\nesac\n</code></pre>"},{"location":"lang/shell/#functionality-reuse","title":"Functionality Reuse","text":"<ul> <li>Reuse Existing Functionality: Whenever possible, leverage existing shell utilities, commands,   and functions rather than reinventing the wheel. This promotes code reuse, reduces maintenance   overhead, and encourages consistency.</li> </ul> <pre><code># Use existing utility to count lines in a file\nline_count=$(wc -l &lt; \"$file\")\n</code></pre>"},{"location":"lang/shell/#tools-and-ide-setup","title":"Tools and IDE Setup","text":"<p>Setting up the right tools and IDE environment is crucial for efficient shell scripting and ensuring code quality. Here's a guide to configuring your development environment for optimal shell scripting productivity.</p>"},{"location":"lang/shell/#linting","title":"Linting","text":"<ul> <li>ShellCheck: Integrate ShellCheck into your development workflow   to catch common issues, syntax errors, and pitfalls in your shell scripts. ShellCheck provides   valuable feedback on script correctness and adherence to best practices.</li> </ul>"},{"location":"lang/shell/#terminal-emulators","title":"Terminal Emulators","text":"<ul> <li> <p>Optimize Your Terminal Environment: Configure your terminal emulator to suit your shell   scripting needs, including customizing the prompt, enabling syntax highlighting, and setting up   keyboard shortcuts for common tasks.</p> <ul> <li>iTerm2 (macOS): Feature-rich terminal emulator with support for   split panes, customizable profiles, and integration with shell scripting tools.</li> <li>Gnome Terminal - A terminal emulator for GNOME.</li> <li>Hyper - A terminal built on web technologies.</li> </ul> </li> </ul>"},{"location":"lang/shell/#shell-specific-ides","title":"Shell-Specific IDEs","text":"<ul> <li>Bash IDE: A lightweight IDE for   Bash scripting with features like syntax highlighting, auto-completion, and code snippets.</li> <li>IntelliJ IDEA: IntelliJ IDEA   provides coding assistance for shell script files</li> </ul>"},{"location":"lang/shell/#package-managers","title":"Package Managers","text":"<ul> <li>Package Management for Shell Scripts: Utilize package managers like Homebrew (macOS), APT (   Linux), or Chocolatey (Windows) to install and manage dependencies for shell scripting tools and   utilities. Package managers streamline the installation process and ensure consistent tool   versions across development environments.</li> </ul>"},{"location":"lang/shell/#shells-and-frameworks","title":"Shells and Frameworks","text":"<ul> <li>bash - GNU Project's shell (Bourne Again SHell)</li> <li>fish - Smart and user-friendly command line shell</li> <li>PowerShell - PowerShell for every system!</li> <li>powershell a cross-platform task   automation and configuration management framework, consisting of a command-line shell and   scripting language</li> <li>zsh - Powerful shell with scripting language</li> <li>ohmyzsh/ohmyzsh - A delightful community-driven framework   for managing your zsh configuration.</li> </ul>"},{"location":"lang/shell/#guides-and-tutorials","title":"Guides and Tutorials","text":"<ul> <li>Bash Official Reference Manual</li> <li>Bash Hackers Wiki</li> <li>Greg Wooledge's (aka \"greycat\") wiki.</li> <li>Google's Shell Style Guide</li> <li>The Linux Documentation Project: Bash Programming - Intro/How-to</li> <li>The Linux Documentation Project: Advanced Bash Scripting Guide</li> <li>The Art of Command Line</li> <li>A guide to learn bash</li> </ul>"},{"location":"lang/swift/","title":"Swift Style Guide","text":"<p>This guide focuses on the best practices for writing Swift code, emphasizing readability, maintainability, and adherence to modern Swift idioms.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for Swift.</p> <p>The formatting rules for Swift adhere to our foundational formatting standards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation, 4 spaces for continuation lines.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, parentheses, braces, colons, commas, and keywords.</li> <li>Brace Style: Follow K&amp;R style (opening brace on same line, closing brace on new line).</li> <li>Blank Lines: Use 1 line to separate code sections.</li> <li>Alignment: Align elements in documentation comments and parameter lists.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/swift/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for Swift adhere to our foundational naming conventions with the following exception:</p> <ul> <li>camelCase for constants to follow Swift's convention.</li> </ul> <p>Otherwise, follow the conventions outlined in the foundational standards.</p> <ul> <li>PascalCase for classes, structs, enums, and protocols.</li> <li>camelCase for functions, variables, constants, and enum cases.</li> </ul>"},{"location":"lang/swift/#protocol-naming","title":"Protocol Naming","text":"<ul> <li>Descriptive Nouns: Protocols that describe what something is should be named as nouns   (e.g., <code>Collection</code>).</li> <li>Capabilities: Protocols that describe capabilities should end in <code>-able</code>, <code>-ible</code>, or <code>-ing</code>   (e.g., <code>Equatable</code>, <code>ProgressReporting</code>).</li> </ul>"},{"location":"lang/swift/#initializers","title":"Initializers","text":"<ul> <li>Property Correspondence: Initializer arguments that directly correspond to stored properties   should share the same name, using <code>self.</code> to disambiguate.</li> </ul>"},{"location":"lang/swift/#commenting-and-documentation","title":"Commenting and Documentation","text":"<p>Documentation plays a crucial role in Swift development, serving as a guide for future developers, including the future you, and facilitating understanding and maintenance of the codebase. This section outlines the conventions and best practices for writing documentation comments in Swift.</p>"},{"location":"lang/swift/#documentation-format","title":"Documentation Format","text":"<p>Documentation comments in Swift are written using triple slashes (<code>///</code>). Block comments (<code>/** ... */</code>), common in other languages for documentation purposes, are not used in Swift.</p> <pre><code>/// Fetches the list of available goats from the server.\n///\n/// This function contacts the server and retrieves the current list of goats available for adoption.\n/// It uses an asynchronous call and returns the data in a completion handler.\nfunc fetchAvailableGoats(completion: @escaping ([Goat]) -&gt; Void) {\n  // Implementation\n}\n</code></pre>"},{"location":"lang/swift/#single-sentence-summary","title":"Single-Sentence Summary","text":"<p>Documentation comments should start with a brief single-sentence summary that concisely describes the purpose of the function, method, or property. This summary may span multiple lines if necessary but should be kept as succinct as possible.</p> <p>If further detail is required, additional paragraphs, each separated by a blank line, can follow the summary. The summary itself should avoid starting with redundant phrases such as \"This method...\" as the context is implied.</p> <pre><code>/// Returns the calculated age of a goat based on its birth date.\n///\n/// The age is calculated with respect to the current date. This method considers leap years.\n/// The calculation does not include the time of day the goat was born, considering only the date.\n///\n/// - Parameter birthDate: The birth date of the goat.\n/// - Returns: The age of the goat in years.\nfunc calculateGoatAge(birthDate: Date) -&gt; Int {\n  // Implementation\n}\n</code></pre>"},{"location":"lang/swift/#parameter-returns-and-throws-tags","title":"Parameter, Returns, and Throws Tags","text":"<p>Document the parameters, return value, and errors a function or method may throw using the <code>Parameter(s)</code>, <code>Returns</code>, and <code>Throws</code> tags, respectively. These tags should not be left with empty descriptions, and their content should end with a period, even if they form a phrase rather than a complete sentence.</p> <p>When a description does not fit on a single line, continuation lines should be indented by two spaces.</p> <pre><code>/// Enrolls a goat in a specified class.\n///\n/// This method enrolls a goat in the class if it meets the prerequisites. It throws an error if\n/// the goat is already enrolled in the maximum number of classes or if the class is full.\n///\n/// - Parameters:\n///   - goat: The goat to enroll.\n///   - className: The name of the class to enroll the goat in.\n/// - Returns: A boolean indicating whether the enrollment was successful.\n/// - Throws: `GoatEnrollmentError.classFull` if the class is full,\n///           `GoatEnrollmentError.maxEnrollmentsReached` if the goat has reached the maximum number of enrollments.\nfunc enrollGoat(goat: Goat, className: String) throws -&gt; Bool {\n  // Implementation\n}\n</code></pre>"},{"location":"lang/swift/#apples-markup-format","title":"Apple\u2019s Markup Format","text":"<p>Using Apple\u2019s markup format in documentation comments is encouraged to add rich formatting. This markup differentiates symbolic references from descriptive text and supports rendering by Xcode and documentation generation tools.</p> <ul> <li>Use <code>backticks</code> for inline code and symbol names.</li> <li>Use triple backticks (```) to denote multi-line code blocks.</li> <li>Emphasize text with asterisks or underscores.</li> </ul>"},{"location":"lang/swift/#where-to-document","title":"Where to Document","text":"<p>At a minimum, provide documentation comments for every <code>open</code> or <code>public</code> declaration, and every <code>open</code> or <code>public</code> member of such declarations. Exceptions include:</p> <ul> <li>Enum cases that are self-explanatory may not require documentation unless they have associated   values that need clarification.</li> <li>Overrides, protocol requirement implementations, or default protocol requirement implementations   may omit documentation if the super declaration is adequately documented, except to describe new   behavior.</li> </ul> <p>Keep documentation focused, relevant, and concise to ensure it remains useful and maintainable. Documentation comments are optional but recommended for test classes and methods, particularly for functional tests or shared helper methods.</p>"},{"location":"lang/swift/#comments","title":"Comments","text":"<p>Comments should be used judiciously to explain why a piece of code does something. Avoid redundant comments that simply describe what the code does.</p>"},{"location":"lang/swift/#best-practices-and-idioms","title":"Best Practices and Idioms","text":""},{"location":"lang/swift/#embrace-swifts-type-system","title":"Embrace Swift's Type System","text":"<p>Swift's type system is designed to be both powerful and expressive. Leverage the type system for safer and more readable code.</p> <ul> <li>Prefer Strong Typing Over Casting: Use specific types over general types (e.g., prefer <code>Int</code>   over <code>Any</code>) to avoid unnecessary casting.</li> <li>Type Inference: Utilize Swift's type inference capabilities to keep code clean and concise   without sacrificing type safety.</li> </ul>"},{"location":"lang/swift/#error-handling","title":"Error Handling","text":"<p>Swift introduces a robust error handling model. Use <code>throw</code> and <code>catch</code> to handle errors in a clear and predictable manner.</p> <ul> <li>Use <code>throws</code> Judiciously: Only use <code>throws</code> in functions where error handling adds clear   value.</li> <li>Prefer Enums for Error Types: When defining your own errors, use enums that conform to   the <code>Error</code> protocol to categorize error states.</li> </ul>"},{"location":"lang/swift/#optionals","title":"Optionals","text":"<p>Optionals are a powerful feature of Swift, allowing variables to have a 'no value' state.</p> <ul> <li>Use Optionals When Nil Is a Valid Value: Only use optionals for variables that can   legitimately have a <code>nil</code> value.</li> <li>Prefer <code>if let</code> and <code>guard let</code> Over Forced Unwrapping: Use optional binding to safely unwrap   optionals and avoid runtime crashes.</li> </ul>"},{"location":"lang/swift/#code-organization","title":"Code Organization","text":"<p>Organize code logically and consistently to enhance readability and maintainability.</p> <ul> <li>Group Related Functionality: Use extensions to organize your code into logical blocks. This   practice is particularly useful for conforming to protocols.</li> <li>Minimize Global Functions: Encapsulate functions within types when they're highly related to a   specific operation or functionality.</li> </ul>"},{"location":"lang/swift/#use-of-self","title":"Use of Self","text":"<p>The explicit use of <code>self</code> is unnecessary in most cases in Swift, except where required by the compiler or for clarity in closures.</p> <ul> <li>Implicit Self: Prefer omitting <code>self</code> when accessing properties or methods to reduce   verbosity.</li> </ul>"},{"location":"lang/swift/#closures","title":"Closures","text":"<p>Closures are first-class citizens in Swift and should be used effectively to write concise and readable code.</p> <ul> <li>Trailing Closure Syntax: Use trailing closure syntax for the last closure parameter to make   the code cleaner.</li> <li>Closure Parameter Names: Omit the parameter names in short, non-nested closures for   conciseness.</li> </ul>"},{"location":"lang/swift/#protocol-conformance","title":"Protocol Conformance","text":"<p>Conform to protocols to leverage Swift's powerful protocol-oriented programming paradigm.</p> <ul> <li>Separate Protocol Conformance: Use extensions to clearly separate protocol conformance in your   class or struct implementations.</li> <li>Prefer Composition Over Inheritance: Use protocols for shared functionality across types   rather than class inheritance.</li> </ul>"},{"location":"lang/swift/#constants-and-variables","title":"Constants and Variables","text":"<p>Use <code>let</code> to declare constants and <code>var</code> for variables. Prefer immutability wherever possible to make your code safer and clearer.</p>"},{"location":"lang/swift/#avoiding-magic-numbers","title":"Avoiding Magic Numbers","text":"<p>Prefer named constants over in-line literals to make your code more readable and maintainable. Magic numbers in the code can lead to confusion and errors.</p>"},{"location":"lang/swift/#leverage-value-types","title":"Leverage Value Types","text":"<p>Swift's preference for value types (structs and enums) over reference types (classes) for data encapsulation ensures immutability and thread safety.</p> <ul> <li>Use Structs for Data Models: Prefer structs for simple data holding models, taking advantage   of automatic memberwise initializers and value semantics.</li> </ul>"},{"location":"lang/swift/#protocol-oriented-programming","title":"Protocol-Oriented Programming","text":"<p>Swift is renowned for its powerful protocol-oriented programming model.</p> <ul> <li>Favor Protocols Over Base Classes: Design APIs around protocols and protocol extensions. This   approach promotes loose coupling and enhances code reusability.</li> </ul>"},{"location":"lang/swift/#functional-programming-patterns","title":"Functional Programming Patterns","text":"<p>Swift's support for first-class functions and closures encourages the use of functional programming techniques.</p> <ul> <li>Embrace Higher-Order Functions: Utilize functions like <code>map</code>, <code>filter</code>, <code>reduce</code> for concise   operations on collections, promoting clearer and more expressive code.</li> </ul>"},{"location":"lang/swift/#avoid-force-unwrapping","title":"Avoid Force Unwrapping","text":"<p>Force unwrapping optionals (<code>!</code>) bypasses safety checks and can lead to runtime crashes.</p> <ul> <li>Safe Unwrapping: Always unwrap optionals using safe methods (e.g., optional binding, nil   coalescing <code>??</code>) unless you're absolutely certain the value isn't <code>nil</code>.</li> </ul>"},{"location":"lang/swift/#use-of-guard-statements","title":"Use of <code>guard</code> Statements","text":"<p>Guard statements are a distinctive Swift feature, allowing for early exits and ensuring that variables have valid values before proceeding.</p> <ul> <li>Early Exit: Use <code>guard</code> for conditions that must be met for the function to continue   execution. This reduces nesting and enhances readability.</li> </ul>"},{"location":"lang/swift/#tools-and-resources","title":"Tools and Resources","text":""},{"location":"lang/swift/#linting-and-formatting-tools","title":"Linting and Formatting Tools","text":"<ul> <li>SwiftLint: A tool to enforce Swift style and conventions.</li> <li>SwiftFormat: An automatic code formatter for Swift.</li> </ul>"},{"location":"lang/swift/#static-analysis-tools","title":"Static Analysis Tools","text":"<ul> <li>Swift Compiler Warnings: Utilize the Swift compiler's built-in static analysis to catch common   errors and code smells.</li> <li>Xcode Analyze: Use Xcode's Analyze feature to detect potential bugs and issues in your code.</li> </ul>"},{"location":"lang/swift/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift Programming Language Guide: The official guide to Swift, offering   a comprehensive overview of the language.</li> <li>Swift API Design Guidelines: Guidelines for designing Swift APIs   that are expressive and easy to use.</li> <li>Ray Wenderlich's Swift Style Guide: A community-driven style guide for   Swift.</li> </ul>"},{"location":"lang/typescript/","title":"TypeScript Style Guide","text":"<p>This guide specifically addresses TypeScript development, focusing on idiomatic practices, patterns, and TypeScript-specific considerations.</p> <p>Foundational Code Standards provide the foundation, this guide extends them for TypeScript.</p>"},{"location":"lang/typescript/#formatting","title":"Formatting","text":"<p>The formatting rules for TypeScript adhere to our foundational formatting standards:</p> <ul> <li>Consistent Indentation: Use 2 spaces for indentation.</li> <li>Line Length: Aim for 100 characters, but allow flexibility for readability.</li> <li>Whitespace: Use spaces around operators, after colons and semicolons, and before open braces   for clarity.</li> <li>Brace Style: Use 1TBS (the one true brace style) where the opening brace is on the same line.</li> <li>Semicolons: Use semicolons at the end of statements for clarity.</li> </ul> <p>Remember, these are guidelines; adapt them for your project's needs while keeping readability in focus.</p>"},{"location":"lang/typescript/#naming-conventions","title":"Naming Conventions","text":"<p>The naming conventions for TypeScript adhere to our foundational naming conventions with no exceptions.</p> <ul> <li>PascalCase for classes, interfaces, enums (definitions).</li> <li>camelCase for functions, variables, properties.<ul> <li>Prefix booleans with <code>is</code> or <code>has</code> for clarity.</li> </ul> </li> <li>UPPER_SNAKE_CASE for constants.</li> <li>lowercase package names, concatenated words (avoid underscores).</li> </ul> <p>Additional Tips:</p> <ul> <li>Interfaces: Use PascalCase without an <code>I</code> prefix.</li> <li>Types: Use PascalCase for type aliases and enum types.</li> <li>Members: Public members should not have an underscore prefix.</li> </ul>"},{"location":"lang/typescript/#documentation-and-comments","title":"Documentation and Comments","text":"<p>Refer to the Foundational Code Standards for general commenting and documentation guidelines. In TypeScript, use TSDoc for documenting code. Document all public APIs clearly with examples where applicable.</p>"},{"location":"lang/typescript/#idioms-and-best-practices","title":"Idioms and Best Practices","text":""},{"location":"lang/typescript/#use-typescripts-type-system-effectively","title":"Use TypeScript\u2019s Type System Effectively","text":"<ul> <li>Leverage Advanced Types: TypeScript offers powerful features like generics, enums, union types, and intersection types. Use these to create precise and flexible type definitions.</li> </ul> <pre><code>type Action =\n    | { type: 'FEED_GOAT'; payload: { goatId: string; food: string } }\n    | { type: 'PET_GOAT'; payload: { goatId: string } };\n\nfunction handleGoatAction(action: Action) {\n    // Implementation\n}\n</code></pre>"},{"location":"lang/typescript/#avoid-using-any-type","title":"Avoid Using <code>any</code> Type","text":"<ul> <li>Specify Types Explicitly: Minimize the use of the <code>any</code> type to maintain the benefits of TypeScript's static typing. Use <code>unknown</code> if the type is genuinely uncertain and validate it.</li> </ul> <p>Good<pre><code>function safelyParse(jsonString: string): unknown {\n  return JSON.parse(jsonString);\n}\n</code></pre> Avoid<pre><code>function parse(jsonString: string): any {\n  return JSON.parse(jsonString);\n}\n</code></pre></p>"},{"location":"lang/typescript/#enums-and-union-types-for-state-management","title":"Enums and Union Types for State Management","text":"<ul> <li>Prefer Union Types Over Enums for Simplicity: While enums can be useful, consider using union types for states or categories to reduce complexity and enhance tree-shaking.</li> </ul> <p>Good<pre><code>type GoatMood = 'happy' | 'hungry' | 'sleepy';\n</code></pre> Less preferred for simple cases<pre><code>enum GoatMood {\n    Happy,\n    Hungry,\n    Sleepy,\n}\n</code></pre></p>"},{"location":"lang/typescript/#embrace-null-safety","title":"Embrace Null Safety","text":"<ul> <li>Optional Chaining and Nullish Coalescing: Use optional chaining (<code>?.</code>) and nullish coalescing (<code>??</code>) operators to write cleaner, safer code that elegantly handles null and undefined values.</li> </ul> <p>Good<pre><code>const goatName = goat?.name ?? 'Unknown Goat';\n</code></pre> Avoid<pre><code>const goatName = goat &amp;&amp; goat.name ? goat.name : 'Unknown Goat';\n</code></pre></p>"},{"location":"lang/typescript/#modular-code-organization","title":"Modular Code Organization","text":"<ul> <li>Organize Code with ES Modules: Structure your project using modules to encapsulate functionality and promote reuse. Import and export types, interfaces, functions, and classes to keep the codebase organized and maintainable.</li> </ul> <pre><code>// In goat.ts\nexport class Goat {\n  constructor(public name: string) {}\n}\n\n// In main.ts\nimport { Goat } from './goat';\n</code></pre>"},{"location":"lang/typescript/#use-decorators-for-cross-cutting-concerns","title":"Use Decorators for Cross-Cutting Concerns","text":"<ul> <li>Apply Decorators Wisely: TypeScript's experimental decorator feature can be used to annotate and modify classes and properties elegantly, especially in frameworks like Angular.</li> </ul> <pre><code>@Component({\n  selector: 'goat-list',\n  templateUrl: './goat-list.component.html',\n})\nexport class GoatListComponent {\n  // Component logic\n}\n</code></pre>"},{"location":"lang/typescript/#functional-programming-techniques","title":"Functional Programming Techniques","text":"<ul> <li>Immutability and Pure Functions: Adopt functional programming principles where appropriate. Use immutable data patterns and write pure functions to improve predictability and facilitate testing.</li> </ul> <p>Good<pre><code>function feedGoat(goat: Goat, food: string): Goat {\n  return { ...goat, lastFedWith: food };\n}\n</code></pre> Avoid<pre><code>function feedGoat(goat: Goat, food: string): void {\n  goat.lastFedWith = food;\n}\n</code></pre></p>"},{"location":"lang/typescript/#prefer-interfaces-over-types-for-object-shapes","title":"Prefer Interfaces over Types for Object Shapes","text":"<p>Use interfaces for defining object shapes due to their extendability.</p> <pre><code>interface Goat {\n  name: string;\n  age: number;\n}\n</code></pre>"},{"location":"lang/typescript/#asyncawait-over-promises","title":"Async/Await over Promises","text":"<p>Use async/await for asynchronous code for better readability and error handling.</p>"},{"location":"lang/typescript/#modularize-code","title":"Modularize Code","text":"<p>Organize code into modules and use explicit import and export statements.</p>"},{"location":"lang/typescript/#tools-and-resources","title":"Tools and Resources","text":"<p>Ensuring a consistent development environment and utilizing static analysis tools are crucial steps for maintaining high code quality in TypeScript projects.</p>"},{"location":"lang/typescript/#recommended-static-analysis-tools-for-typescript","title":"Recommended Static Analysis Tools for TypeScript","text":"<p>Static analysis tools help identify potential issues early in the development process. For TypeScript, several tools are particularly effective:</p> <ul> <li>TSLint: A linter that checks TypeScript code for readability, maintainability, and functionality errors.</li> <li>ESLint: A pluggable and configurable linter tool for identifying and reporting on patterns in JavaScript/TypeScript.</li> </ul>"},{"location":"lang/typescript/#additional-resources","title":"Additional Resources","text":"<p>To further enhance your TypeScript development skills and knowledge, consider exploring the following resources:</p> <ul> <li>TypeScript Documentation: The official TypeScript documentation, offering in-depth guides and reference materials.</li> <li>DefinitelyTyped: A repository of high-quality TypeScript type definitions.</li> </ul>"}]}